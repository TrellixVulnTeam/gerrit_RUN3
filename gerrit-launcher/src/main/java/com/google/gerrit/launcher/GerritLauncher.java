begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2009 The Android Open Source Project
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Licensed under the Apache License, Version 2.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License.
end_comment

begin_comment
comment|// You may obtain a copy of the License at
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// http://www.apache.org/licenses/LICENSE-2.0
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unless required by applicable law or agreed to in writing, software
end_comment

begin_comment
comment|// distributed under the License is distributed on an "AS IS" BASIS,
end_comment

begin_comment
comment|// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing permissions and
end_comment

begin_comment
comment|// limitations under the License.
end_comment

begin_package
DECL|package|com.google.gerrit.launcher
package|package
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|launcher
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|DAYS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|JarURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|CodeSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import

begin_comment
comment|/** Main class for a JAR file to run code from "WEB-INF/lib". */
end_comment

begin_class
DECL|class|GerritLauncher
specifier|public
specifier|final
class|class
name|GerritLauncher
block|{
DECL|field|pkg
specifier|private
specifier|static
specifier|final
name|String
name|pkg
init|=
literal|"com.google.gerrit.pgm"
decl_stmt|;
DECL|field|NOT_ARCHIVED
specifier|public
specifier|static
specifier|final
name|String
name|NOT_ARCHIVED
init|=
literal|"NOT_ARCHIVED"
decl_stmt|;
DECL|method|main (final String argv[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
specifier|final
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|exit
argument_list|(
name|mainImpl
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|mainImpl (final String argv[])
specifier|private
specifier|static
name|int
name|mainImpl
parameter_list|(
specifier|final
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|File
name|me
decl_stmt|;
try|try
block|{
name|me
operator|=
name|getDistributionArchive
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|me
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|jar
init|=
name|me
operator|!=
literal|null
condition|?
name|me
operator|.
name|getName
argument_list|()
else|:
literal|"gerrit.war"
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Gerrit Code Review "
operator|+
name|getVersion
argument_list|(
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java -jar "
operator|+
name|jar
operator|+
literal|" command [ARG ...]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The most commonly used commands are:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  init           Initialize a Gerrit installation"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  daemon         Run the Gerrit network daemons"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  gsql           Run the interactive query console"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  version        Display the build version number"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  ls             List files available for cat"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  cat FILE       Display a file from the archive"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Special cases, a few global options actually are programs.
comment|//
if|if
condition|(
literal|"-v"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--version"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"version"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-p"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--cat"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"cat"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-l"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--ls"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"ls"
expr_stmt|;
block|}
comment|// Run the application class
comment|//
specifier|final
name|ClassLoader
name|cl
init|=
name|libClassLoader
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setContextClassLoader
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
name|invokeProgram
argument_list|(
name|cl
argument_list|,
name|argv
argument_list|)
return|;
block|}
DECL|method|getVersion (final File me)
specifier|private
specifier|static
name|String
name|getVersion
parameter_list|(
specifier|final
name|File
name|me
parameter_list|)
block|{
if|if
condition|(
name|me
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
try|try
block|{
specifier|final
name|JarFile
name|jar
init|=
operator|new
name|JarFile
argument_list|(
name|me
argument_list|)
decl_stmt|;
try|try
block|{
name|Manifest
name|mf
init|=
name|jar
operator|.
name|getManifest
argument_list|()
decl_stmt|;
name|Attributes
name|att
init|=
name|mf
operator|.
name|getMainAttributes
argument_list|()
decl_stmt|;
name|String
name|val
init|=
name|att
operator|.
name|getValue
argument_list|(
name|Attributes
operator|.
name|Name
operator|.
name|IMPLEMENTATION_VERSION
argument_list|)
decl_stmt|;
return|return
name|val
operator|!=
literal|null
condition|?
name|val
else|:
literal|""
return|;
block|}
finally|finally
block|{
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|""
return|;
block|}
block|}
DECL|method|invokeProgram (final ClassLoader loader, final String[] origArgv)
specifier|private
specifier|static
name|int
name|invokeProgram
parameter_list|(
specifier|final
name|ClassLoader
name|loader
parameter_list|,
specifier|final
name|String
index|[]
name|origArgv
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|name
init|=
name|origArgv
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|argv
init|=
operator|new
name|String
index|[
name|origArgv
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|origArgv
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
name|argv
operator|.
name|length
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|String
name|cn
init|=
name|name
decl_stmt|;
if|if
condition|(
name|cn
operator|.
name|equals
argument_list|(
name|cn
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|cn
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'-'
operator|&&
name|i
operator|+
literal|1
operator|<
name|cn
operator|.
name|length
argument_list|()
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cn
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|pkg
operator|+
literal|"."
operator|+
name|cn
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|pkg
operator|+
literal|"."
operator|+
name|name
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|cnfe
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"fatal: unknown command "
operator|+
name|name
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"      (no "
operator|+
name|pkg
operator|+
literal|"."
operator|+
name|name
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|final
name|Method
name|main
decl_stmt|;
try|try
block|{
name|main
operator|=
name|clazz
operator|.
name|getMethod
argument_list|(
literal|"main"
argument_list|,
name|argv
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"fatal: unknown command "
operator|+
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"fatal: unknown command "
operator|+
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|final
name|Object
name|res
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|main
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|STATIC
operator|)
operator|==
name|Modifier
operator|.
name|STATIC
condition|)
block|{
name|res
operator|=
name|main
operator|.
name|invoke
argument_list|(
literal|null
argument_list|,
operator|new
name|Object
index|[]
block|{
name|argv
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|main
operator|.
name|invoke
argument_list|(
name|clazz
operator|.
name|newInstance
argument_list|()
argument_list|,
operator|new
name|Object
index|[]
block|{
name|argv
block|}
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
if|if
condition|(
name|ite
operator|.
name|getCause
argument_list|()
operator|instanceof
name|Exception
condition|)
block|{
throw|throw
operator|(
name|Exception
operator|)
name|ite
operator|.
name|getCause
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|ite
operator|.
name|getCause
argument_list|()
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|ite
operator|.
name|getCause
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|ite
throw|;
block|}
block|}
if|if
condition|(
name|res
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|res
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|libClassLoader ()
specifier|private
specifier|static
name|ClassLoader
name|libClassLoader
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|File
name|path
decl_stmt|;
try|try
block|{
name|path
operator|=
name|getDistributionArchive
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NOT_ARCHIVED
operator|==
name|e
operator|.
name|getMessage
argument_list|()
condition|)
block|{
comment|// Assume the CLASSPATH was made complete by the calling process,
comment|// as we are likely being run from within a developer's IDE.
comment|//
return|return
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
return|;
block|}
throw|throw
name|e
throw|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|ZipFile
name|zf
init|=
operator|new
name|ZipFile
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|Enumeration
argument_list|<
name|?
extends|extends
name|ZipEntry
argument_list|>
name|e
init|=
name|zf
operator|.
name|entries
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
specifier|final
name|ZipEntry
name|ze
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|ze
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ze
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"WEB-INF/lib/"
argument_list|)
condition|)
block|{
name|extractJar
argument_list|(
name|zf
argument_list|,
name|ze
argument_list|,
name|jars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ze
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"WEB-INF/pgm-lib/"
argument_list|)
condition|)
block|{
name|extractJar
argument_list|(
name|zf
argument_list|,
name|ze
argument_list|,
name|jars
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|zf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot obtain libraries from "
operator|+
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|jars
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
return|;
block|}
comment|// The extension API needs to be its own ClassLoader, along
comment|// with a few of its dependencies. Try to construct this first.
name|List
argument_list|<
name|URL
argument_list|>
name|extapi
init|=
operator|new
name|ArrayList
argument_list|<
name|URL
argument_list|>
argument_list|()
decl_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"gerrit-extension-api-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"guice-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"javax.inject-1.jar"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"aopalliance-1.0.jar"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"guice-servlet-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"tomcat-servlet-api-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|ClassLoader
name|parent
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|extapi
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parent
operator|=
operator|new
name|URLClassLoader
argument_list|(
name|extapi
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|extapi
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|URLClassLoader
argument_list|(
name|jars
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|jars
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|parent
argument_list|)
return|;
block|}
DECL|method|extractJar (ZipFile zf, ZipEntry ze, SortedMap<String, URL> jars)
specifier|private
specifier|static
name|void
name|extractJar
parameter_list|(
name|ZipFile
name|zf
parameter_list|,
name|ZipEntry
name|ze
parameter_list|,
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|tmp
init|=
name|createTempFile
argument_list|(
name|safeName
argument_list|(
name|ze
argument_list|)
argument_list|,
literal|".jar"
argument_list|)
decl_stmt|;
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
try|try
block|{
name|InputStream
name|in
init|=
name|zf
operator|.
name|getInputStream
argument_list|(
name|ze
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|String
name|name
init|=
name|ze
operator|.
name|getName
argument_list|()
decl_stmt|;
name|jars
operator|.
name|put
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|tmp
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|move (SortedMap<String, URL> jars, String prefix, List<URL> extapi)
specifier|private
specifier|static
name|void
name|move
parameter_list|(
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
parameter_list|,
name|String
name|prefix
parameter_list|,
name|List
argument_list|<
name|URL
argument_list|>
name|extapi
parameter_list|)
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|matches
init|=
name|jars
operator|.
name|tailMap
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|first
init|=
name|matches
operator|.
name|firstKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|extapi
operator|.
name|add
argument_list|(
name|jars
operator|.
name|remove
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|safeName (final ZipEntry ze)
specifier|private
specifier|static
name|String
name|safeName
parameter_list|(
specifier|final
name|ZipEntry
name|ze
parameter_list|)
block|{
comment|// Try to derive the name of the temporary file so it
comment|// doesn't completely suck. Best if we can make it
comment|// match the name it was in the archive.
comment|//
name|String
name|name
init|=
name|ze
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
literal|"code"
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|field|myArchive
specifier|private
specifier|volatile
specifier|static
name|File
name|myArchive
decl_stmt|;
DECL|field|myHome
specifier|private
specifier|static
name|File
name|myHome
decl_stmt|;
comment|/**    * Locate the JAR/WAR file we were launched from.    *    * @return local path of the Gerrit WAR file.    * @throws FileNotFoundException if the code cannot guess the location.    */
DECL|method|getDistributionArchive ()
specifier|public
specifier|static
name|File
name|getDistributionArchive
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
name|myArchive
operator|==
literal|null
condition|)
block|{
name|myArchive
operator|=
name|locateMyArchive
argument_list|()
expr_stmt|;
block|}
return|return
name|myArchive
return|;
block|}
DECL|method|locateMyArchive ()
specifier|private
specifier|static
name|File
name|locateMyArchive
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|ClassLoader
name|myCL
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
specifier|final
name|String
name|myName
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|".class"
decl_stmt|;
specifier|final
name|URL
name|myClazz
init|=
name|myCL
operator|.
name|getResource
argument_list|(
name|myName
argument_list|)
decl_stmt|;
if|if
condition|(
name|myClazz
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find JAR: no "
operator|+
name|myName
argument_list|)
throw|;
block|}
comment|// ZipFile may have the path of our JAR hiding within itself.
comment|//
try|try
block|{
name|Field
name|nameField
init|=
name|ZipFile
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|nameField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|JarFile
name|jar
init|=
operator|(
operator|(
name|JarURLConnection
operator|)
name|myClazz
operator|.
name|openConnection
argument_list|()
operator|)
operator|.
name|getJarFile
argument_list|()
decl_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
operator|(
name|String
operator|)
name|nameField
operator|.
name|get
argument_list|(
name|jar
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
name|path
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Nope, that didn't work. Try a different method.
comment|//
block|}
comment|// Maybe this is a local class file, running under a debugger?
comment|//
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|myClazz
operator|.
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|myClazz
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|isFile
argument_list|()
operator|&&
name|path
operator|.
name|getParentFile
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|NOT_ARCHIVED
argument_list|)
throw|;
block|}
block|}
comment|// The CodeSource might be able to give us the source as a stream.
comment|// If so, copy it to a local file so we have random access to it.
comment|//
specifier|final
name|CodeSource
name|src
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getProtectionDomain
argument_list|()
operator|.
name|getCodeSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|InputStream
name|in
init|=
name|src
operator|.
name|getLocation
argument_list|()
operator|.
name|openStream
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|File
name|tmp
init|=
name|createTempFile
argument_list|(
literal|"gerrit_"
argument_list|,
literal|".zip"
argument_list|)
decl_stmt|;
specifier|final
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Nope, that didn't work.
comment|//
block|}
block|}
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find local copy of JAR"
argument_list|)
throw|;
block|}
DECL|field|temporaryDirectoryFound
specifier|private
specifier|static
name|boolean
name|temporaryDirectoryFound
decl_stmt|;
DECL|field|temporaryDirectory
specifier|private
specifier|static
name|File
name|temporaryDirectory
decl_stmt|;
comment|/**    * Creates a temporary file within the application's unpack location.    *<p>    * The launcher unpacks the nested JAR files into a temporary directory,    * allowing the classes to be loaded from local disk with standard Java APIs.    * This method constructs a new temporary file in the same directory.    *<p>    * The method first tries to create {@code prefix + suffix} within the    * directory under the assumption that a given {@code prefix + suffix}    * combination is made at most once per JVM execution. If this fails (e.g. the    * named file already exists) a mangled unique name is used and returned    * instead, with the unique string appearing between the prefix and suffix.    *<p>    * Files created by this method will be automatically deleted by the JVM when    * it terminates. If the returned file is converted into a directory by the    * caller, the caller must arrange for the contents to be deleted before the    * directory is.    *<p>    * If supported by the underlying operating system, the temporary directory    * which contains these temporary files is accessible only by the user running    * the JVM.    *    * @param prefix prefix of the file name.    * @param suffix suffix of the file name.    * @return the path of the temporary file. The returned object exists in the    *         filesystem as a file; caller may need to delete and recreate as a    *         directory if a directory was preferred.    * @throws IOException the file could not be created.    */
DECL|method|createTempFile (String prefix, String suffix)
specifier|public
specifier|static
specifier|synchronized
name|File
name|createTempFile
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|temporaryDirectoryFound
condition|)
block|{
specifier|final
name|File
name|d
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"gerrit_"
argument_list|,
literal|"_app"
argument_list|,
name|tmproot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|delete
argument_list|()
operator|&&
name|d
operator|.
name|mkdir
argument_list|()
condition|)
block|{
comment|// Try to lock the directory down to be accessible by us.
comment|// We first have to remove all permissions, then add back
comment|// only the owner permissions.
comment|//
name|d
operator|.
name|setWritable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setReadable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setExecutable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setWritable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setReadable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|temporaryDirectory
operator|=
name|d
expr_stmt|;
block|}
name|temporaryDirectoryFound
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|temporaryDirectory
operator|!=
literal|null
condition|)
block|{
comment|// If we have a private directory and this name has not yet
comment|// been used within the private directory, create it as-is.
comment|//
specifier|final
name|File
name|tmp
init|=
operator|new
name|File
argument_list|(
name|temporaryDirectory
argument_list|,
name|prefix
operator|+
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|createNewFile
argument_list|()
condition|)
block|{
name|tmp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
block|}
if|if
condition|(
operator|!
name|prefix
operator|.
name|endsWith
argument_list|(
literal|"_"
argument_list|)
condition|)
block|{
name|prefix
operator|+=
literal|"_"
expr_stmt|;
block|}
specifier|final
name|File
name|tmp
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|temporaryDirectory
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
comment|/**    * Provide path to a working directory    *    * @return local path of the working directory or null if cannot be determined    */
DECL|method|getHomeDirectory ()
specifier|public
specifier|static
name|File
name|getHomeDirectory
parameter_list|()
block|{
if|if
condition|(
name|myHome
operator|==
literal|null
condition|)
block|{
name|myHome
operator|=
name|locateHomeDirectory
argument_list|()
expr_stmt|;
block|}
return|return
name|myHome
return|;
block|}
DECL|method|tmproot ()
specifier|private
specifier|static
name|File
name|tmproot
parameter_list|()
block|{
name|File
name|tmp
decl_stmt|;
name|String
name|gerritTemp
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"GERRIT_TMP"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gerritTemp
operator|!=
literal|null
operator|&&
name|gerritTemp
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|new
name|File
argument_list|(
name|gerritTemp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|new
name|File
argument_list|(
name|getHomeDirectory
argument_list|()
argument_list|,
literal|"tmp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|tmp
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot create "
operator|+
name|tmp
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Try to clean up any stale empty directories. Assume any empty
comment|// directory that is older than 7 days is one of these dead ones
comment|// that we can clean up.
comment|//
specifier|final
name|File
index|[]
name|tmpEntries
init|=
name|tmp
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmpEntries
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expired
init|=
name|now
operator|-
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|7
argument_list|,
name|DAYS
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|File
name|tmpEntry
range|:
name|tmpEntries
control|)
block|{
if|if
condition|(
name|tmpEntry
operator|.
name|isDirectory
argument_list|()
operator|&&
name|tmpEntry
operator|.
name|lastModified
argument_list|()
operator|<
name|expired
condition|)
block|{
specifier|final
name|String
index|[]
name|all
init|=
name|tmpEntry
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|all
operator|==
literal|null
operator|||
name|all
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tmpEntry
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
try|try
block|{
return|return
name|tmp
operator|.
name|getCanonicalFile
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|tmp
return|;
block|}
block|}
DECL|method|locateHomeDirectory ()
specifier|private
specifier|static
name|File
name|locateHomeDirectory
parameter_list|()
block|{
comment|// Try to find the user's home directory. If we can't find it
comment|// return null so the JVM's default temporary directory is used
comment|// instead. This is probably /tmp or /var/tmp.
comment|//
name|String
name|userHome
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.home"
argument_list|)
decl_stmt|;
if|if
condition|(
name|userHome
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|userHome
argument_list|)
condition|)
block|{
name|userHome
operator|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|userHome
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|userHome
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot determine home directory"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// Ensure the home directory exists. If it doesn't, try to make it.
comment|//
specifier|final
name|File
name|home
init|=
operator|new
name|File
argument_list|(
name|userHome
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|home
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|home
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: created "
operator|+
name|home
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|home
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// Use $HOME/.gerritcodereview/tmp for our temporary file area.
comment|//
specifier|final
name|File
name|gerrithome
init|=
operator|new
name|File
argument_list|(
name|home
argument_list|,
literal|".gerritcodereview"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gerrithome
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|gerrithome
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot create "
operator|+
name|gerrithome
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
name|gerrithome
operator|.
name|getCanonicalFile
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|gerrithome
return|;
block|}
block|}
DECL|method|GerritLauncher ()
specifier|private
name|GerritLauncher
parameter_list|()
block|{   }
block|}
end_class

end_unit

