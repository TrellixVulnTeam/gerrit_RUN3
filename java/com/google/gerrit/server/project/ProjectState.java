begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2008 The Android Open Source Project
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Licensed under the Apache License, Version 2.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License.
end_comment

begin_comment
comment|// You may obtain a copy of the License at
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// http://www.apache.org/licenses/LICENSE-2.0
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unless required by applicable law or agreed to in writing, software
end_comment

begin_comment
comment|// distributed under the License is distributed on an "AS IS" BASIS,
end_comment

begin_comment
comment|// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing permissions and
end_comment

begin_comment
comment|// limitations under the License.
end_comment

begin_package
DECL|package|com.google.gerrit.server.project
package|package
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|project
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|PermissionRule
operator|.
name|Action
operator|.
name|ALLOW
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|FluentIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|AccessSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|GroupReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|LabelType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|LabelTypes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|PermissionRule
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|RefConfigSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|SubscribeSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|api
operator|.
name|projects
operator|.
name|CommentLinkInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|api
operator|.
name|projects
operator|.
name|ThemeInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|client
operator|.
name|SubmitType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|restapi
operator|.
name|ResourceConflictException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|index
operator|.
name|project
operator|.
name|ProjectData
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|AccountGroup
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|BooleanProjectConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|Branch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|RefNames
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|CurrentUser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|account
operator|.
name|CapabilityCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|AllProjectsName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|AllUsersName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|SitePaths
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|BranchOrderSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|GitRepositoryManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|ProjectConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|notedb
operator|.
name|ChangeNotes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|rules
operator|.
name|PrologEnvironment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|rules
operator|.
name|RulesCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|assistedinject
operator|.
name|Assisted
import|;
end_import

begin_import
import|import
name|com
operator|.
name|googlecode
operator|.
name|prolog_cafe
operator|.
name|exceptions
operator|.
name|CompileException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|googlecode
operator|.
name|prolog_cafe
operator|.
name|lang
operator|.
name|PrologMachineCopy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|errors
operator|.
name|ConfigInvalidException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/** Cached information on a project. */
end_comment

begin_class
DECL|class|ProjectState
specifier|public
class|class
name|ProjectState
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProjectState
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|interface|Factory
specifier|public
interface|interface
name|Factory
block|{
DECL|method|create (ProjectConfig config)
name|ProjectState
name|create
parameter_list|(
name|ProjectConfig
name|config
parameter_list|)
function_decl|;
block|}
DECL|field|isAllProjects
specifier|private
specifier|final
name|boolean
name|isAllProjects
decl_stmt|;
DECL|field|isAllUsers
specifier|private
specifier|final
name|boolean
name|isAllUsers
decl_stmt|;
DECL|field|sitePaths
specifier|private
specifier|final
name|SitePaths
name|sitePaths
decl_stmt|;
DECL|field|allProjectsName
specifier|private
specifier|final
name|AllProjectsName
name|allProjectsName
decl_stmt|;
DECL|field|projectCache
specifier|private
specifier|final
name|ProjectCache
name|projectCache
decl_stmt|;
DECL|field|envFactory
specifier|private
specifier|final
name|PrologEnvironment
operator|.
name|Factory
name|envFactory
decl_stmt|;
DECL|field|gitMgr
specifier|private
specifier|final
name|GitRepositoryManager
name|gitMgr
decl_stmt|;
DECL|field|rulesCache
specifier|private
specifier|final
name|RulesCache
name|rulesCache
decl_stmt|;
DECL|field|commentLinks
specifier|private
specifier|final
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|commentLinks
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|ProjectConfig
name|config
decl_stmt|;
DECL|field|configs
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ProjectLevelConfig
argument_list|>
name|configs
decl_stmt|;
DECL|field|localOwners
specifier|private
specifier|final
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|localOwners
decl_stmt|;
comment|/** Prolog rule state. */
DECL|field|rulesMachine
specifier|private
specifier|volatile
name|PrologMachineCopy
name|rulesMachine
decl_stmt|;
comment|/** Last system time the configuration's revision was examined. */
DECL|field|lastCheckGeneration
specifier|private
specifier|volatile
name|long
name|lastCheckGeneration
decl_stmt|;
comment|/** Local access sections, wrapped in SectionMatchers for faster evaluation. */
DECL|field|localAccessSections
specifier|private
specifier|volatile
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|localAccessSections
decl_stmt|;
comment|/** Theme information loaded from site_path/themes. */
DECL|field|theme
specifier|private
specifier|volatile
name|ThemeInfo
name|theme
decl_stmt|;
comment|/** If this is all projects, the capabilities used by the server. */
DECL|field|capabilities
specifier|private
specifier|final
name|CapabilityCollection
name|capabilities
decl_stmt|;
comment|/** All label types applicable to changes in this project. */
DECL|field|labelTypes
specifier|private
name|LabelTypes
name|labelTypes
decl_stmt|;
annotation|@
name|Inject
DECL|method|ProjectState ( final SitePaths sitePaths, final ProjectCache projectCache, final AllProjectsName allProjectsName, final AllUsersName allUsersName, final PrologEnvironment.Factory envFactory, final GitRepositoryManager gitMgr, final RulesCache rulesCache, final List<CommentLinkInfo> commentLinks, final CapabilityCollection.Factory limitsFactory, @Assisted final ProjectConfig config)
specifier|public
name|ProjectState
parameter_list|(
specifier|final
name|SitePaths
name|sitePaths
parameter_list|,
specifier|final
name|ProjectCache
name|projectCache
parameter_list|,
specifier|final
name|AllProjectsName
name|allProjectsName
parameter_list|,
specifier|final
name|AllUsersName
name|allUsersName
parameter_list|,
specifier|final
name|PrologEnvironment
operator|.
name|Factory
name|envFactory
parameter_list|,
specifier|final
name|GitRepositoryManager
name|gitMgr
parameter_list|,
specifier|final
name|RulesCache
name|rulesCache
parameter_list|,
specifier|final
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|commentLinks
parameter_list|,
specifier|final
name|CapabilityCollection
operator|.
name|Factory
name|limitsFactory
parameter_list|,
annotation|@
name|Assisted
specifier|final
name|ProjectConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|sitePaths
operator|=
name|sitePaths
expr_stmt|;
name|this
operator|.
name|projectCache
operator|=
name|projectCache
expr_stmt|;
name|this
operator|.
name|isAllProjects
operator|=
name|config
operator|.
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
operator|.
name|equals
argument_list|(
name|allProjectsName
argument_list|)
expr_stmt|;
name|this
operator|.
name|isAllUsers
operator|=
name|config
operator|.
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
operator|.
name|equals
argument_list|(
name|allUsersName
argument_list|)
expr_stmt|;
name|this
operator|.
name|allProjectsName
operator|=
name|allProjectsName
expr_stmt|;
name|this
operator|.
name|envFactory
operator|=
name|envFactory
expr_stmt|;
name|this
operator|.
name|gitMgr
operator|=
name|gitMgr
expr_stmt|;
name|this
operator|.
name|rulesCache
operator|=
name|rulesCache
expr_stmt|;
name|this
operator|.
name|commentLinks
operator|=
name|commentLinks
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|configs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|capabilities
operator|=
name|isAllProjects
condition|?
name|limitsFactory
operator|.
name|create
argument_list|(
name|config
operator|.
name|getAccessSection
argument_list|(
name|AccessSection
operator|.
name|GLOBAL_CAPABILITIES
argument_list|)
argument_list|)
else|:
literal|null
expr_stmt|;
if|if
condition|(
name|isAllProjects
operator|&&
operator|!
name|Permission
operator|.
name|canBeOnAllProjects
argument_list|(
name|AccessSection
operator|.
name|ALL
argument_list|,
name|Permission
operator|.
name|OWNER
argument_list|)
condition|)
block|{
name|localOwners
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|HashSet
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|groups
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|AccessSection
name|all
init|=
name|config
operator|.
name|getAccessSection
argument_list|(
name|AccessSection
operator|.
name|ALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|all
operator|!=
literal|null
condition|)
block|{
name|Permission
name|owner
init|=
name|all
operator|.
name|getPermission
argument_list|(
name|Permission
operator|.
name|OWNER
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PermissionRule
name|rule
range|:
name|owner
operator|.
name|getRules
argument_list|()
control|)
block|{
name|GroupReference
name|ref
init|=
name|rule
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|rule
operator|.
name|getAction
argument_list|()
operator|==
name|ALLOW
operator|&&
name|ref
operator|.
name|getUUID
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|ref
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|localOwners
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initLastCheck (long generation)
name|void
name|initLastCheck
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
name|lastCheckGeneration
operator|=
name|generation
expr_stmt|;
block|}
DECL|method|needsRefresh (long generation)
name|boolean
name|needsRefresh
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
if|if
condition|(
name|generation
operator|<=
literal|0
condition|)
block|{
return|return
name|isRevisionOutOfDate
argument_list|()
return|;
block|}
if|if
condition|(
name|lastCheckGeneration
operator|!=
name|generation
condition|)
block|{
name|lastCheckGeneration
operator|=
name|generation
expr_stmt|;
return|return
name|isRevisionOutOfDate
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|isRevisionOutOfDate ()
specifier|private
name|boolean
name|isRevisionOutOfDate
parameter_list|()
block|{
try|try
init|(
name|Repository
name|git
init|=
name|gitMgr
operator|.
name|openRepository
argument_list|(
name|getNameKey
argument_list|()
argument_list|)
init|)
block|{
name|Ref
name|ref
init|=
name|git
operator|.
name|getRefDatabase
argument_list|()
operator|.
name|exactRef
argument_list|(
name|RefNames
operator|.
name|REFS_CONFIG
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|null
operator|||
name|ref
operator|.
name|getObjectId
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|!
name|ref
operator|.
name|getObjectId
argument_list|()
operator|.
name|equals
argument_list|(
name|config
operator|.
name|getRevision
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|gone
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * @return cached computation of all global capabilities. This should only be invoked on the state    *     from {@link ProjectCache#getAllProjects()}. Null on any other project.    */
DECL|method|getCapabilityCollection ()
specifier|public
name|CapabilityCollection
name|getCapabilityCollection
parameter_list|()
block|{
return|return
name|capabilities
return|;
block|}
comment|/**    * Returns true if the Prolog engine is expected to run for this project, that is if this project    * or a parent possesses a rules.pl file.    */
DECL|method|hasPrologRules ()
specifier|public
name|boolean
name|hasPrologRules
parameter_list|()
block|{
comment|// We check if this project has a rules.pl file
if|if
condition|(
name|getConfig
argument_list|()
operator|.
name|getRulesId
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If not, we check the parents.
return|return
name|parents
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ProjectState
operator|::
name|getConfig
argument_list|)
operator|.
name|map
argument_list|(
name|ProjectConfig
operator|::
name|getRulesId
argument_list|)
operator|.
name|anyMatch
argument_list|(
name|Objects
operator|::
name|nonNull
argument_list|)
return|;
block|}
comment|/** @return Construct a new PrologEnvironment for the calling thread. */
DECL|method|newPrologEnvironment ()
specifier|public
name|PrologEnvironment
name|newPrologEnvironment
parameter_list|()
throws|throws
name|CompileException
block|{
name|PrologMachineCopy
name|pmc
init|=
name|rulesMachine
decl_stmt|;
if|if
condition|(
name|pmc
operator|==
literal|null
condition|)
block|{
name|pmc
operator|=
name|rulesCache
operator|.
name|loadMachine
argument_list|(
name|getNameKey
argument_list|()
argument_list|,
name|config
operator|.
name|getRulesId
argument_list|()
argument_list|)
expr_stmt|;
name|rulesMachine
operator|=
name|pmc
expr_stmt|;
block|}
return|return
name|envFactory
operator|.
name|create
argument_list|(
name|pmc
argument_list|)
return|;
block|}
comment|/**    * Like {@link #newPrologEnvironment()} but instead of reading the rules.pl read the provided    * input stream.    *    * @param name a name of the input stream. Could be any name.    * @param in stream to read prolog rules from    * @throws CompileException    */
DECL|method|newPrologEnvironment (String name, Reader in)
specifier|public
name|PrologEnvironment
name|newPrologEnvironment
parameter_list|(
name|String
name|name
parameter_list|,
name|Reader
name|in
parameter_list|)
throws|throws
name|CompileException
block|{
name|PrologMachineCopy
name|pmc
init|=
name|rulesCache
operator|.
name|loadMachine
argument_list|(
name|name
argument_list|,
name|in
argument_list|)
decl_stmt|;
return|return
name|envFactory
operator|.
name|create
argument_list|(
name|pmc
argument_list|)
return|;
block|}
DECL|method|getProject ()
specifier|public
name|Project
name|getProject
parameter_list|()
block|{
return|return
name|config
operator|.
name|getProject
argument_list|()
return|;
block|}
DECL|method|getNameKey ()
specifier|public
name|Project
operator|.
name|NameKey
name|getNameKey
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|getNameKey
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getConfig ()
specifier|public
name|ProjectConfig
name|getConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
DECL|method|getConfig (String fileName)
specifier|public
name|ProjectLevelConfig
name|getConfig
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|configs
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
return|return
name|configs
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
return|;
block|}
name|ProjectLevelConfig
name|cfg
init|=
operator|new
name|ProjectLevelConfig
argument_list|(
name|fileName
argument_list|,
name|this
argument_list|)
decl_stmt|;
try|try
init|(
name|Repository
name|git
init|=
name|gitMgr
operator|.
name|openRepository
argument_list|(
name|getNameKey
argument_list|()
argument_list|)
init|)
block|{
name|cfg
operator|.
name|load
argument_list|(
name|git
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ConfigInvalidException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to load "
operator|+
name|fileName
operator|+
literal|" for "
operator|+
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|configs
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
return|return
name|cfg
return|;
block|}
DECL|method|getMaxObjectSizeLimit ()
specifier|public
name|long
name|getMaxObjectSizeLimit
parameter_list|()
block|{
return|return
name|config
operator|.
name|getMaxObjectSizeLimit
argument_list|()
return|;
block|}
DECL|method|statePermitsRead ()
specifier|public
name|boolean
name|statePermitsRead
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|permitsRead
argument_list|()
return|;
block|}
DECL|method|checkStatePermitsRead ()
specifier|public
name|void
name|checkStatePermitsRead
parameter_list|()
throws|throws
name|ResourceConflictException
block|{
if|if
condition|(
operator|!
name|statePermitsRead
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ResourceConflictException
argument_list|(
literal|"project state "
operator|+
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|" does not permit read"
argument_list|)
throw|;
block|}
block|}
DECL|method|statePermitsWrite ()
specifier|public
name|boolean
name|statePermitsWrite
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|permitsWrite
argument_list|()
return|;
block|}
DECL|method|checkStatePermitsWrite ()
specifier|public
name|void
name|checkStatePermitsWrite
parameter_list|()
throws|throws
name|ResourceConflictException
block|{
if|if
condition|(
operator|!
name|statePermitsWrite
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ResourceConflictException
argument_list|(
literal|"project state "
operator|+
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|" does not permit write"
argument_list|)
throw|;
block|}
block|}
comment|/** Get the sections that pertain only to this project. */
DECL|method|getLocalAccessSections ()
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|getLocalAccessSections
parameter_list|()
block|{
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|sm
init|=
name|localAccessSections
decl_stmt|;
if|if
condition|(
name|sm
operator|==
literal|null
condition|)
block|{
name|Collection
argument_list|<
name|AccessSection
argument_list|>
name|fromConfig
init|=
name|config
operator|.
name|getAccessSections
argument_list|()
decl_stmt|;
name|sm
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fromConfig
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|AccessSection
name|section
range|:
name|fromConfig
control|)
block|{
if|if
condition|(
name|isAllProjects
condition|)
block|{
name|List
argument_list|<
name|Permission
argument_list|>
name|copy
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|section
operator|.
name|getPermissions
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Permission
name|p
range|:
name|section
operator|.
name|getPermissions
argument_list|()
control|)
block|{
if|if
condition|(
name|Permission
operator|.
name|canBeOnAllProjects
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|section
operator|=
operator|new
name|AccessSection
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|section
operator|.
name|setPermissions
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
name|SectionMatcher
name|matcher
init|=
name|SectionMatcher
operator|.
name|wrap
argument_list|(
name|getNameKey
argument_list|()
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|!=
literal|null
condition|)
block|{
name|sm
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
name|localAccessSections
operator|=
name|sm
expr_stmt|;
block|}
return|return
name|sm
return|;
block|}
comment|/**    * Obtain all local and inherited sections. This collection is looked up dynamically and is not    * cached. Callers should try to cache this result per-request as much as possible.    */
DECL|method|getAllSections ()
specifier|public
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|getAllSections
parameter_list|()
block|{
if|if
condition|(
name|isAllProjects
condition|)
block|{
return|return
name|getLocalAccessSections
argument_list|()
return|;
block|}
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|all
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|all
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|getLocalAccessSections
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|all
return|;
block|}
comment|/**    * @return all {@link AccountGroup}'s to which the owner privilege for 'refs/*' is assigned for    *     this project (the local owners), if there are no local owners the local owners of the    *     nearest parent project that has local owners are returned    */
DECL|method|getOwners ()
specifier|public
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|getOwners
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|p
range|:
name|tree
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|.
name|localOwners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|p
operator|.
name|localOwners
return|;
block|}
block|}
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|/**    * @return all {@link AccountGroup}'s that are allowed to administrate the complete project. This    *     includes all groups to which the owner privilege for 'refs/*' is assigned for this project    *     (the local owners) and all groups to which the owner privilege for 'refs/*' is assigned for    *     one of the parent projects (the inherited owners).    */
DECL|method|getAllOwners ()
specifier|public
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|getAllOwners
parameter_list|()
block|{
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|p
range|:
name|tree
argument_list|()
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|p
operator|.
name|localOwners
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @return an iterable that walks through this project and then the parents of this project.    *     Starts from this project and progresses up the hierarchy to All-Projects.    */
DECL|method|tree ()
specifier|public
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
name|tree
parameter_list|()
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|ProjectState
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ProjectHierarchyIterator
argument_list|(
name|projectCache
argument_list|,
name|allProjectsName
argument_list|,
name|ProjectState
operator|.
name|this
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * @return an iterable that walks in-order from All-Projects through the project hierarchy to this    *     project.    */
DECL|method|treeInOrder ()
specifier|public
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
name|treeInOrder
parameter_list|()
block|{
name|List
argument_list|<
name|ProjectState
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|tree
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|projects
argument_list|)
expr_stmt|;
return|return
name|projects
return|;
block|}
comment|/**    * @return an iterable that walks through the parents of this project. Starts from the immediate    *     parent of this project and progresses up the hierarchy to All-Projects.    */
DECL|method|parents ()
specifier|public
name|FluentIterable
argument_list|<
name|ProjectState
argument_list|>
name|parents
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|tree
argument_list|()
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
return|;
block|}
DECL|method|isAllProjects ()
specifier|public
name|boolean
name|isAllProjects
parameter_list|()
block|{
return|return
name|isAllProjects
return|;
block|}
DECL|method|isAllUsers ()
specifier|public
name|boolean
name|isAllUsers
parameter_list|()
block|{
return|return
name|isAllUsers
return|;
block|}
DECL|method|is (BooleanProjectConfig config)
specifier|public
name|boolean
name|is
parameter_list|(
name|BooleanProjectConfig
name|config
parameter_list|)
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
switch|switch
condition|(
name|s
operator|.
name|getProject
argument_list|()
operator|.
name|getBooleanConfig
argument_list|(
name|config
argument_list|)
condition|)
block|{
case|case
name|TRUE
case|:
return|return
literal|true
return|;
case|case
name|FALSE
case|:
return|return
literal|false
return|;
case|case
name|INHERIT
case|:
default|default:
continue|continue;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** All available label types. */
DECL|method|getLabelTypes ()
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|()
block|{
if|if
condition|(
name|labelTypes
operator|==
literal|null
condition|)
block|{
name|labelTypes
operator|=
name|loadLabelTypes
argument_list|()
expr_stmt|;
block|}
return|return
name|labelTypes
return|;
block|}
comment|/** All available label types for this change and user. */
DECL|method|getLabelTypes (ChangeNotes notes, CurrentUser user)
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|(
name|ChangeNotes
name|notes
parameter_list|,
name|CurrentUser
name|user
parameter_list|)
block|{
return|return
name|getLabelTypes
argument_list|(
name|notes
operator|.
name|getChange
argument_list|()
operator|.
name|getDest
argument_list|()
argument_list|,
name|user
argument_list|)
return|;
block|}
comment|/** All available label types for this branch and user. */
DECL|method|getLabelTypes (Branch.NameKey destination, CurrentUser user)
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|(
name|Branch
operator|.
name|NameKey
name|destination
parameter_list|,
name|CurrentUser
name|user
parameter_list|)
block|{
name|List
argument_list|<
name|LabelType
argument_list|>
name|all
init|=
name|getLabelTypes
argument_list|()
operator|.
name|getLabelTypes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LabelType
argument_list|>
name|r
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|all
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LabelType
name|l
range|:
name|all
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|refs
init|=
name|l
operator|.
name|getRefPatterns
argument_list|()
decl_stmt|;
if|if
condition|(
name|refs
operator|==
literal|null
condition|)
block|{
name|r
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|refPattern
range|:
name|refs
control|)
block|{
if|if
condition|(
name|RefConfigSection
operator|.
name|isValid
argument_list|(
name|refPattern
argument_list|)
operator|&&
name|match
argument_list|(
name|destination
argument_list|,
name|refPattern
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|r
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
operator|new
name|LabelTypes
argument_list|(
name|r
argument_list|)
return|;
block|}
DECL|method|getCommentLinks ()
specifier|public
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|getCommentLinks
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|CommentLinkInfo
argument_list|>
name|cls
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CommentLinkInfo
name|cl
range|:
name|commentLinks
control|)
block|{
name|cls
operator|.
name|put
argument_list|(
name|cl
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ProjectState
name|s
range|:
name|treeInOrder
argument_list|()
control|)
block|{
for|for
control|(
name|CommentLinkInfoImpl
name|cl
range|:
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getCommentLinkSections
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|cl
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|isOverrideOnly
argument_list|()
condition|)
block|{
name|CommentLinkInfo
name|parent
init|=
name|cls
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// Ignore invalid overrides.
block|}
name|cls
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|cl
operator|.
name|inherit
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cls
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|cls
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getBranchOrderSection ()
specifier|public
name|BranchOrderSection
name|getBranchOrderSection
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|BranchOrderSection
name|section
init|=
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getBranchOrderSection
argument_list|()
decl_stmt|;
if|if
condition|(
name|section
operator|!=
literal|null
condition|)
block|{
return|return
name|section
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getSubscribeSections (Branch.NameKey branch)
specifier|public
name|Collection
argument_list|<
name|SubscribeSection
argument_list|>
name|getSubscribeSections
parameter_list|(
name|Branch
operator|.
name|NameKey
name|branch
parameter_list|)
block|{
name|Collection
argument_list|<
name|SubscribeSection
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|ret
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getSubscribeSections
argument_list|(
name|branch
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getTheme ()
specifier|public
name|ThemeInfo
name|getTheme
parameter_list|()
block|{
name|ThemeInfo
name|theme
init|=
name|this
operator|.
name|theme
decl_stmt|;
if|if
condition|(
name|theme
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|theme
operator|=
name|this
operator|.
name|theme
expr_stmt|;
if|if
condition|(
name|theme
operator|==
literal|null
condition|)
block|{
name|theme
operator|=
name|loadTheme
argument_list|()
expr_stmt|;
name|this
operator|.
name|theme
operator|=
name|theme
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|theme
operator|==
name|ThemeInfo
operator|.
name|INHERIT
condition|)
block|{
name|ProjectState
name|parent
init|=
name|Iterables
operator|.
name|getFirst
argument_list|(
name|parents
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|parent
operator|!=
literal|null
condition|?
name|parent
operator|.
name|getTheme
argument_list|()
else|:
literal|null
return|;
block|}
return|return
name|theme
return|;
block|}
DECL|method|getAllGroups ()
specifier|public
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getAllGroups
parameter_list|()
block|{
return|return
name|getGroups
argument_list|(
name|getAllSections
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getLocalGroups ()
specifier|public
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getLocalGroups
parameter_list|()
block|{
return|return
name|getGroups
argument_list|(
name|getLocalAccessSections
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getSubmitType ()
specifier|public
name|SubmitType
name|getSubmitType
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|SubmitType
name|t
init|=
name|s
operator|.
name|getProject
argument_list|()
operator|.
name|getConfiguredSubmitType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|SubmitType
operator|.
name|INHERIT
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
return|return
name|Project
operator|.
name|DEFAULT_ALL_PROJECTS_SUBMIT_TYPE
return|;
block|}
DECL|method|getGroups (List<SectionMatcher> sectionMatcherList)
specifier|private
specifier|static
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getGroups
parameter_list|(
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|sectionMatcherList
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|all
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SectionMatcher
name|matcher
range|:
name|sectionMatcherList
control|)
block|{
specifier|final
name|AccessSection
name|section
init|=
name|matcher
operator|.
name|getSection
argument_list|()
decl_stmt|;
for|for
control|(
name|Permission
name|permission
range|:
name|section
operator|.
name|getPermissions
argument_list|()
control|)
block|{
for|for
control|(
name|PermissionRule
name|rule
range|:
name|permission
operator|.
name|getRules
argument_list|()
control|)
block|{
name|all
operator|.
name|add
argument_list|(
name|rule
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|all
return|;
block|}
DECL|method|loadTheme ()
specifier|private
name|ThemeInfo
name|loadTheme
parameter_list|()
block|{
name|String
name|name
init|=
name|getConfig
argument_list|()
operator|.
name|getProject
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Path
name|dir
init|=
name|sitePaths
operator|.
name|themes_dir
operator|.
name|resolve
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
return|return
name|ThemeInfo
operator|.
name|INHERIT
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Files
operator|.
name|isDirectory
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Bad theme for {}: not a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ThemeInfo
operator|.
name|INHERIT
return|;
block|}
try|try
block|{
return|return
operator|new
name|ThemeInfo
argument_list|(
name|readFile
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
name|SitePaths
operator|.
name|CSS_FILENAME
argument_list|)
argument_list|)
argument_list|,
name|readFile
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
name|SitePaths
operator|.
name|HEADER_FILENAME
argument_list|)
argument_list|)
argument_list|,
name|readFile
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
name|SitePaths
operator|.
name|FOOTER_FILENAME
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error reading theme for "
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|ThemeInfo
operator|.
name|INHERIT
return|;
block|}
block|}
DECL|method|toProjectData ()
specifier|public
name|ProjectData
name|toProjectData
parameter_list|()
block|{
return|return
operator|new
name|ProjectData
argument_list|(
name|getProject
argument_list|()
argument_list|,
name|parents
argument_list|()
operator|.
name|transform
argument_list|(
name|s
lambda|->
name|s
operator|.
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|readFile (Path p)
specifier|private
name|String
name|readFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|?
operator|new
name|String
argument_list|(
name|Files
operator|.
name|readAllBytes
argument_list|(
name|p
argument_list|)
argument_list|,
name|UTF_8
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|loadLabelTypes ()
specifier|private
name|LabelTypes
name|loadLabelTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|LabelType
argument_list|>
name|types
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|s
range|:
name|treeInOrder
argument_list|()
control|)
block|{
for|for
control|(
name|LabelType
name|type
range|:
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getLabelSections
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|lower
init|=
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|LabelType
name|old
init|=
name|types
operator|.
name|get
argument_list|(
name|lower
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
operator|||
name|old
operator|.
name|canOverride
argument_list|()
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|lower
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|LabelType
argument_list|>
name|all
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LabelType
name|type
range|:
name|types
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|getValues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|all
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|LabelTypes
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|all
argument_list|)
argument_list|)
return|;
block|}
DECL|method|match (Branch.NameKey destination, String refPattern, CurrentUser user)
specifier|private
name|boolean
name|match
parameter_list|(
name|Branch
operator|.
name|NameKey
name|destination
parameter_list|,
name|String
name|refPattern
parameter_list|,
name|CurrentUser
name|user
parameter_list|)
block|{
return|return
name|RefPatternMatcher
operator|.
name|getMatcher
argument_list|(
name|refPattern
argument_list|)
operator|.
name|match
argument_list|(
name|destination
operator|.
name|get
argument_list|()
argument_list|,
name|user
argument_list|)
return|;
block|}
block|}
end_class

end_unit

