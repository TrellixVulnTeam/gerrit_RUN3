begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2008 The Android Open Source Project
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Licensed under the Apache License, Version 2.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License.
end_comment

begin_comment
comment|// You may obtain a copy of the License at
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// http://www.apache.org/licenses/LICENSE-2.0
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unless required by applicable law or agreed to in writing, software
end_comment

begin_comment
comment|// distributed under the License is distributed on an "AS IS" BASIS,
end_comment

begin_comment
comment|// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing permissions and
end_comment

begin_comment
comment|// limitations under the License.
end_comment

begin_package
DECL|package|com.google.gerrit.server.project
package|package
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|project
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|PermissionRule
operator|.
name|Action
operator|.
name|ALLOW
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|FluentIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|flogger
operator|.
name|FluentLogger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|AccessSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|GroupReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|LabelType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|LabelTypes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|PermissionRule
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|data
operator|.
name|SubscribeSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|api
operator|.
name|projects
operator|.
name|CommentLinkInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|client
operator|.
name|SubmitType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|restapi
operator|.
name|ResourceConflictException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|index
operator|.
name|project
operator|.
name|ProjectData
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|metrics
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|metrics
operator|.
name|Description
operator|.
name|Units
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|metrics
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|metrics
operator|.
name|MetricMaker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|metrics
operator|.
name|Timer1
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|AccountGroup
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|BooleanProjectConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|Branch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|RefNames
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|account
operator|.
name|CapabilityCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|AllProjectsName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|AllUsersName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|BranchOrderSection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|GitRepositoryManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|TransferConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|notedb
operator|.
name|ChangeNotes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|assistedinject
operator|.
name|Assisted
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|errors
operator|.
name|ConfigInvalidException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Repository
import|;
end_import

begin_comment
comment|/**  * Cached information on a project. Must not contain any data derived from parents other than it's  * immediate parent's {@link com.google.gerrit.reviewdb.client.Project.NameKey}.  */
end_comment

begin_class
DECL|class|ProjectState
specifier|public
class|class
name|ProjectState
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|FluentLogger
name|logger
init|=
name|FluentLogger
operator|.
name|forEnclosingClass
argument_list|()
decl_stmt|;
DECL|interface|Factory
specifier|public
interface|interface
name|Factory
block|{
DECL|method|create (ProjectConfig config)
name|ProjectState
name|create
parameter_list|(
name|ProjectConfig
name|config
parameter_list|)
function_decl|;
block|}
DECL|field|isAllProjects
specifier|private
specifier|final
name|boolean
name|isAllProjects
decl_stmt|;
DECL|field|isAllUsers
specifier|private
specifier|final
name|boolean
name|isAllUsers
decl_stmt|;
DECL|field|allProjectsName
specifier|private
specifier|final
name|AllProjectsName
name|allProjectsName
decl_stmt|;
DECL|field|projectCache
specifier|private
specifier|final
name|ProjectCache
name|projectCache
decl_stmt|;
DECL|field|gitMgr
specifier|private
specifier|final
name|GitRepositoryManager
name|gitMgr
decl_stmt|;
DECL|field|commentLinks
specifier|private
specifier|final
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|commentLinks
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|ProjectConfig
name|config
decl_stmt|;
DECL|field|configs
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ProjectLevelConfig
argument_list|>
name|configs
decl_stmt|;
DECL|field|localOwners
specifier|private
specifier|final
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|localOwners
decl_stmt|;
DECL|field|globalMaxObjectSizeLimit
specifier|private
specifier|final
name|long
name|globalMaxObjectSizeLimit
decl_stmt|;
DECL|field|inheritProjectMaxObjectSizeLimit
specifier|private
specifier|final
name|boolean
name|inheritProjectMaxObjectSizeLimit
decl_stmt|;
comment|// TODO(hiesel): Remove this once we got production data
DECL|field|computationLatency
specifier|private
specifier|final
name|Timer1
argument_list|<
name|String
argument_list|>
name|computationLatency
decl_stmt|;
comment|/** Last system time the configuration's revision was examined. */
DECL|field|lastCheckGeneration
specifier|private
specifier|volatile
name|long
name|lastCheckGeneration
decl_stmt|;
comment|/** Local access sections, wrapped in SectionMatchers for faster evaluation. */
DECL|field|localAccessSections
specifier|private
specifier|volatile
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|localAccessSections
decl_stmt|;
comment|/** If this is all projects, the capabilities used by the server. */
DECL|field|capabilities
specifier|private
specifier|final
name|CapabilityCollection
name|capabilities
decl_stmt|;
annotation|@
name|Inject
DECL|method|ProjectState ( ProjectCache projectCache, AllProjectsName allProjectsName, AllUsersName allUsersName, GitRepositoryManager gitMgr, List<CommentLinkInfo> commentLinks, CapabilityCollection.Factory limitsFactory, TransferConfig transferConfig, MetricMaker metricMaker, @Assisted ProjectConfig config)
specifier|public
name|ProjectState
parameter_list|(
name|ProjectCache
name|projectCache
parameter_list|,
name|AllProjectsName
name|allProjectsName
parameter_list|,
name|AllUsersName
name|allUsersName
parameter_list|,
name|GitRepositoryManager
name|gitMgr
parameter_list|,
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|commentLinks
parameter_list|,
name|CapabilityCollection
operator|.
name|Factory
name|limitsFactory
parameter_list|,
name|TransferConfig
name|transferConfig
parameter_list|,
name|MetricMaker
name|metricMaker
parameter_list|,
annotation|@
name|Assisted
name|ProjectConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|projectCache
operator|=
name|projectCache
expr_stmt|;
name|this
operator|.
name|isAllProjects
operator|=
name|config
operator|.
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
operator|.
name|equals
argument_list|(
name|allProjectsName
argument_list|)
expr_stmt|;
name|this
operator|.
name|isAllUsers
operator|=
name|config
operator|.
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
operator|.
name|equals
argument_list|(
name|allUsersName
argument_list|)
expr_stmt|;
name|this
operator|.
name|allProjectsName
operator|=
name|allProjectsName
expr_stmt|;
name|this
operator|.
name|gitMgr
operator|=
name|gitMgr
expr_stmt|;
name|this
operator|.
name|commentLinks
operator|=
name|commentLinks
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|configs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|capabilities
operator|=
name|isAllProjects
condition|?
name|limitsFactory
operator|.
name|create
argument_list|(
name|config
operator|.
name|getAccessSection
argument_list|(
name|AccessSection
operator|.
name|GLOBAL_CAPABILITIES
argument_list|)
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|globalMaxObjectSizeLimit
operator|=
name|transferConfig
operator|.
name|getMaxObjectSizeLimit
argument_list|()
expr_stmt|;
name|this
operator|.
name|inheritProjectMaxObjectSizeLimit
operator|=
name|transferConfig
operator|.
name|inheritProjectMaxObjectSizeLimit
argument_list|()
expr_stmt|;
name|this
operator|.
name|computationLatency
operator|=
name|metricMaker
operator|.
name|newTimer
argument_list|(
literal|"permissions/project_state/computation_latency"
argument_list|,
operator|new
name|Description
argument_list|(
literal|"Latency for access computations in ProjectState"
argument_list|)
operator|.
name|setCumulative
argument_list|()
operator|.
name|setUnit
argument_list|(
name|Units
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|Field
operator|.
name|ofString
argument_list|(
literal|"method"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAllProjects
operator|&&
operator|!
name|Permission
operator|.
name|canBeOnAllProjects
argument_list|(
name|AccessSection
operator|.
name|ALL
argument_list|,
name|Permission
operator|.
name|OWNER
argument_list|)
condition|)
block|{
name|localOwners
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|HashSet
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|groups
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|AccessSection
name|all
init|=
name|config
operator|.
name|getAccessSection
argument_list|(
name|AccessSection
operator|.
name|ALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|all
operator|!=
literal|null
condition|)
block|{
name|Permission
name|owner
init|=
name|all
operator|.
name|getPermission
argument_list|(
name|Permission
operator|.
name|OWNER
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PermissionRule
name|rule
range|:
name|owner
operator|.
name|getRules
argument_list|()
control|)
block|{
name|GroupReference
name|ref
init|=
name|rule
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|rule
operator|.
name|getAction
argument_list|()
operator|==
name|ALLOW
operator|&&
name|ref
operator|.
name|getUUID
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|ref
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|localOwners
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initLastCheck (long generation)
name|void
name|initLastCheck
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
name|lastCheckGeneration
operator|=
name|generation
expr_stmt|;
block|}
DECL|method|needsRefresh (long generation)
name|boolean
name|needsRefresh
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
if|if
condition|(
name|generation
operator|<=
literal|0
condition|)
block|{
return|return
name|isRevisionOutOfDate
argument_list|()
return|;
block|}
if|if
condition|(
name|lastCheckGeneration
operator|!=
name|generation
condition|)
block|{
name|lastCheckGeneration
operator|=
name|generation
expr_stmt|;
return|return
name|isRevisionOutOfDate
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|isRevisionOutOfDate ()
specifier|private
name|boolean
name|isRevisionOutOfDate
parameter_list|()
block|{
try|try
init|(
name|Repository
name|git
init|=
name|gitMgr
operator|.
name|openRepository
argument_list|(
name|getNameKey
argument_list|()
argument_list|)
init|)
block|{
name|Ref
name|ref
init|=
name|git
operator|.
name|getRefDatabase
argument_list|()
operator|.
name|exactRef
argument_list|(
name|RefNames
operator|.
name|REFS_CONFIG
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|null
operator|||
name|ref
operator|.
name|getObjectId
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|!
name|ref
operator|.
name|getObjectId
argument_list|()
operator|.
name|equals
argument_list|(
name|config
operator|.
name|getRevision
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|gone
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * @return cached computation of all global capabilities. This should only be invoked on the state    *     from {@link ProjectCache#getAllProjects()}. Null on any other project.    */
DECL|method|getCapabilityCollection ()
specifier|public
name|CapabilityCollection
name|getCapabilityCollection
parameter_list|()
block|{
return|return
name|capabilities
return|;
block|}
comment|/**    * Returns true if the Prolog engine is expected to run for this project, that is if this project    * or a parent possesses a rules.pl file.    */
DECL|method|hasPrologRules ()
specifier|public
name|boolean
name|hasPrologRules
parameter_list|()
block|{
comment|// We check if this project has a rules.pl file
if|if
condition|(
name|getConfig
argument_list|()
operator|.
name|getRulesId
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If not, we check the parents.
return|return
name|parents
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ProjectState
operator|::
name|getConfig
argument_list|)
operator|.
name|map
argument_list|(
name|ProjectConfig
operator|::
name|getRulesId
argument_list|)
operator|.
name|anyMatch
argument_list|(
name|Objects
operator|::
name|nonNull
argument_list|)
return|;
block|}
DECL|method|getProject ()
specifier|public
name|Project
name|getProject
parameter_list|()
block|{
return|return
name|config
operator|.
name|getProject
argument_list|()
return|;
block|}
DECL|method|getNameKey ()
specifier|public
name|Project
operator|.
name|NameKey
name|getNameKey
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getNameKey
argument_list|()
return|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|getNameKey
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getConfig ()
specifier|public
name|ProjectConfig
name|getConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
DECL|method|getConfig (String fileName)
specifier|public
name|ProjectLevelConfig
name|getConfig
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|configs
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
return|return
name|configs
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
return|;
block|}
name|ProjectLevelConfig
name|cfg
init|=
operator|new
name|ProjectLevelConfig
argument_list|(
name|fileName
argument_list|,
name|this
argument_list|)
decl_stmt|;
try|try
init|(
name|Repository
name|git
init|=
name|gitMgr
operator|.
name|openRepository
argument_list|(
name|getNameKey
argument_list|()
argument_list|)
init|)
block|{
name|cfg
operator|.
name|load
argument_list|(
name|getNameKey
argument_list|()
argument_list|,
name|git
argument_list|,
name|config
operator|.
name|getRevision
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ConfigInvalidException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|atWarning
argument_list|()
operator|.
name|withCause
argument_list|(
name|e
argument_list|)
operator|.
name|log
argument_list|(
literal|"Failed to load %s for %s"
argument_list|,
name|fileName
argument_list|,
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|configs
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
return|return
name|cfg
return|;
block|}
DECL|method|getMaxObjectSizeLimit ()
specifier|public
name|long
name|getMaxObjectSizeLimit
parameter_list|()
block|{
return|return
name|config
operator|.
name|getMaxObjectSizeLimit
argument_list|()
return|;
block|}
DECL|method|statePermitsRead ()
specifier|public
name|boolean
name|statePermitsRead
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|permitsRead
argument_list|()
return|;
block|}
DECL|method|checkStatePermitsRead ()
specifier|public
name|void
name|checkStatePermitsRead
parameter_list|()
throws|throws
name|ResourceConflictException
block|{
if|if
condition|(
operator|!
name|statePermitsRead
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ResourceConflictException
argument_list|(
literal|"project state "
operator|+
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|" does not permit read"
argument_list|)
throw|;
block|}
block|}
DECL|method|statePermitsWrite ()
specifier|public
name|boolean
name|statePermitsWrite
parameter_list|()
block|{
return|return
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|permitsWrite
argument_list|()
return|;
block|}
DECL|method|checkStatePermitsWrite ()
specifier|public
name|void
name|checkStatePermitsWrite
parameter_list|()
throws|throws
name|ResourceConflictException
block|{
if|if
condition|(
operator|!
name|statePermitsWrite
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ResourceConflictException
argument_list|(
literal|"project state "
operator|+
name|getProject
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|" does not permit write"
argument_list|)
throw|;
block|}
block|}
DECL|class|EffectiveMaxObjectSizeLimit
specifier|public
specifier|static
class|class
name|EffectiveMaxObjectSizeLimit
block|{
DECL|field|value
specifier|public
name|long
name|value
decl_stmt|;
DECL|field|summary
specifier|public
name|String
name|summary
decl_stmt|;
block|}
DECL|field|MAY_NOT_SET
specifier|private
specifier|static
specifier|final
name|String
name|MAY_NOT_SET
init|=
literal|"This project may not set a higher limit."
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|INHERITED_FROM_PARENT
specifier|public
specifier|static
specifier|final
name|String
name|INHERITED_FROM_PARENT
init|=
literal|"Inherited from parent project '%s'."
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|OVERRIDDEN_BY_PARENT
specifier|public
specifier|static
specifier|final
name|String
name|OVERRIDDEN_BY_PARENT
init|=
literal|"Overridden by parent project '%s'. "
operator|+
name|MAY_NOT_SET
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|INHERITED_FROM_GLOBAL
specifier|public
specifier|static
specifier|final
name|String
name|INHERITED_FROM_GLOBAL
init|=
literal|"Inherited from the global config."
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|OVERRIDDEN_BY_GLOBAL
specifier|public
specifier|static
specifier|final
name|String
name|OVERRIDDEN_BY_GLOBAL
init|=
literal|"Overridden by the global config. "
operator|+
name|MAY_NOT_SET
decl_stmt|;
DECL|method|getEffectiveMaxObjectSizeLimit ()
specifier|public
name|EffectiveMaxObjectSizeLimit
name|getEffectiveMaxObjectSizeLimit
parameter_list|()
block|{
name|EffectiveMaxObjectSizeLimit
name|result
init|=
operator|new
name|EffectiveMaxObjectSizeLimit
argument_list|()
decl_stmt|;
name|result
operator|.
name|value
operator|=
name|config
operator|.
name|getMaxObjectSizeLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|inheritProjectMaxObjectSizeLimit
condition|)
block|{
for|for
control|(
name|ProjectState
name|parent
range|:
name|parents
argument_list|()
control|)
block|{
name|long
name|parentValue
init|=
name|parent
operator|.
name|config
operator|.
name|getMaxObjectSizeLimit
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentValue
operator|>
literal|0
operator|&&
name|result
operator|.
name|value
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|parentValue
operator|<
name|result
operator|.
name|value
condition|)
block|{
name|result
operator|.
name|value
operator|=
name|parentValue
expr_stmt|;
name|result
operator|.
name|summary
operator|=
name|String
operator|.
name|format
argument_list|(
name|OVERRIDDEN_BY_PARENT
argument_list|,
name|parent
operator|.
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parentValue
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|value
operator|=
name|parentValue
expr_stmt|;
name|result
operator|.
name|summary
operator|=
name|String
operator|.
name|format
argument_list|(
name|INHERITED_FROM_PARENT
argument_list|,
name|parent
operator|.
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|globalMaxObjectSizeLimit
operator|>
literal|0
operator|&&
name|result
operator|.
name|value
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|globalMaxObjectSizeLimit
operator|<
name|result
operator|.
name|value
condition|)
block|{
name|result
operator|.
name|value
operator|=
name|globalMaxObjectSizeLimit
expr_stmt|;
name|result
operator|.
name|summary
operator|=
name|OVERRIDDEN_BY_GLOBAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|globalMaxObjectSizeLimit
operator|>
name|result
operator|.
name|value
condition|)
block|{
comment|// zero means "no limit", in this case the max is more limiting
name|result
operator|.
name|value
operator|=
name|globalMaxObjectSizeLimit
expr_stmt|;
name|result
operator|.
name|summary
operator|=
name|INHERITED_FROM_GLOBAL
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Get the sections that pertain only to this project. */
DECL|method|getLocalAccessSections ()
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|getLocalAccessSections
parameter_list|()
block|{
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|sm
init|=
name|localAccessSections
decl_stmt|;
if|if
condition|(
name|sm
operator|==
literal|null
condition|)
block|{
name|Collection
argument_list|<
name|AccessSection
argument_list|>
name|fromConfig
init|=
name|config
operator|.
name|getAccessSections
argument_list|()
decl_stmt|;
name|sm
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fromConfig
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|AccessSection
name|section
range|:
name|fromConfig
control|)
block|{
if|if
condition|(
name|isAllProjects
condition|)
block|{
name|List
argument_list|<
name|Permission
argument_list|>
name|copy
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|section
operator|.
name|getPermissions
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Permission
name|p
range|:
name|section
operator|.
name|getPermissions
argument_list|()
control|)
block|{
if|if
condition|(
name|Permission
operator|.
name|canBeOnAllProjects
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|section
operator|=
operator|new
name|AccessSection
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|section
operator|.
name|setPermissions
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
name|SectionMatcher
name|matcher
init|=
name|SectionMatcher
operator|.
name|wrap
argument_list|(
name|getNameKey
argument_list|()
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|!=
literal|null
condition|)
block|{
name|sm
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
name|localAccessSections
operator|=
name|sm
expr_stmt|;
block|}
return|return
name|sm
return|;
block|}
comment|/**    * Obtain all local and inherited sections. This collection is looked up dynamically and is not    * cached. Callers should try to cache this result per-request as much as possible.    */
DECL|method|getAllSections ()
specifier|public
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|getAllSections
parameter_list|()
block|{
try|try
init|(
name|Timer1
operator|.
name|Context
name|ignored
init|=
name|computationLatency
operator|.
name|start
argument_list|(
literal|"getAllSections"
argument_list|)
init|)
block|{
if|if
condition|(
name|isAllProjects
condition|)
block|{
return|return
name|getLocalAccessSections
argument_list|()
return|;
block|}
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|all
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
name|tree
init|=
name|tree
argument_list|()
decl_stmt|;
try|try
init|(
name|Timer1
operator|.
name|Context
name|ignored2
init|=
name|computationLatency
operator|.
name|start
argument_list|(
literal|"getAllSections-parsing-only"
argument_list|)
init|)
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
control|)
block|{
name|all
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|getLocalAccessSections
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|all
return|;
block|}
block|}
comment|/**    * @return all {@link AccountGroup}'s to which the owner privilege for 'refs/*' is assigned for    *     this project (the local owners), if there are no local owners the local owners of the    *     nearest parent project that has local owners are returned    */
DECL|method|getOwners ()
specifier|public
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|getOwners
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|p
range|:
name|tree
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|.
name|localOwners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|p
operator|.
name|localOwners
return|;
block|}
block|}
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|/**    * @return all {@link AccountGroup}'s that are allowed to administrate the complete project. This    *     includes all groups to which the owner privilege for 'refs/*' is assigned for this project    *     (the local owners) and all groups to which the owner privilege for 'refs/*' is assigned for    *     one of the parent projects (the inherited owners).    */
DECL|method|getAllOwners ()
specifier|public
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|getAllOwners
parameter_list|()
block|{
name|Set
argument_list|<
name|AccountGroup
operator|.
name|UUID
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|p
range|:
name|tree
argument_list|()
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|p
operator|.
name|localOwners
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @return an iterable that walks through this project and then the parents of this project.    *     Starts from this project and progresses up the hierarchy to All-Projects.    */
DECL|method|tree ()
specifier|public
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
name|tree
parameter_list|()
block|{
return|return
parameter_list|()
lambda|->
operator|new
name|ProjectHierarchyIterator
argument_list|(
name|projectCache
argument_list|,
name|allProjectsName
argument_list|,
name|ProjectState
operator|.
name|this
argument_list|)
return|;
block|}
comment|/**    * @return an iterable that walks in-order from All-Projects through the project hierarchy to this    *     project.    */
DECL|method|treeInOrder ()
specifier|public
name|Iterable
argument_list|<
name|ProjectState
argument_list|>
name|treeInOrder
parameter_list|()
block|{
name|List
argument_list|<
name|ProjectState
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|tree
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|projects
argument_list|)
expr_stmt|;
return|return
name|projects
return|;
block|}
comment|/**    * @return an iterable that walks through the parents of this project. Starts from the immediate    *     parent of this project and progresses up the hierarchy to All-Projects.    */
DECL|method|parents ()
specifier|public
name|FluentIterable
argument_list|<
name|ProjectState
argument_list|>
name|parents
parameter_list|()
block|{
return|return
name|FluentIterable
operator|.
name|from
argument_list|(
name|tree
argument_list|()
argument_list|)
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
return|;
block|}
DECL|method|isAllProjects ()
specifier|public
name|boolean
name|isAllProjects
parameter_list|()
block|{
return|return
name|isAllProjects
return|;
block|}
DECL|method|isAllUsers ()
specifier|public
name|boolean
name|isAllUsers
parameter_list|()
block|{
return|return
name|isAllUsers
return|;
block|}
DECL|method|is (BooleanProjectConfig config)
specifier|public
name|boolean
name|is
parameter_list|(
name|BooleanProjectConfig
name|config
parameter_list|)
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
switch|switch
condition|(
name|s
operator|.
name|getProject
argument_list|()
operator|.
name|getBooleanConfig
argument_list|(
name|config
argument_list|)
condition|)
block|{
case|case
name|TRUE
case|:
return|return
literal|true
return|;
case|case
name|FALSE
case|:
return|return
literal|false
return|;
case|case
name|INHERIT
case|:
default|default:
continue|continue;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** All available label types. */
DECL|method|getLabelTypes ()
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|LabelType
argument_list|>
name|types
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|s
range|:
name|treeInOrder
argument_list|()
control|)
block|{
for|for
control|(
name|LabelType
name|type
range|:
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getLabelSections
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|lower
init|=
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|LabelType
name|old
init|=
name|types
operator|.
name|get
argument_list|(
name|lower
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
operator|||
name|old
operator|.
name|canOverride
argument_list|()
condition|)
block|{
name|types
operator|.
name|put
argument_list|(
name|lower
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|LabelType
argument_list|>
name|all
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LabelType
name|type
range|:
name|types
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|getValues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|all
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|LabelTypes
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|all
argument_list|)
argument_list|)
return|;
block|}
comment|/** All available label types for this change. */
DECL|method|getLabelTypes (ChangeNotes notes)
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|(
name|ChangeNotes
name|notes
parameter_list|)
block|{
return|return
name|getLabelTypes
argument_list|(
name|notes
operator|.
name|getChange
argument_list|()
operator|.
name|getDest
argument_list|()
argument_list|)
return|;
block|}
comment|/** All available label types for this branch. */
DECL|method|getLabelTypes (Branch.NameKey destination)
specifier|public
name|LabelTypes
name|getLabelTypes
parameter_list|(
name|Branch
operator|.
name|NameKey
name|destination
parameter_list|)
block|{
name|List
argument_list|<
name|LabelType
argument_list|>
name|all
init|=
name|getLabelTypes
argument_list|()
operator|.
name|getLabelTypes
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LabelType
argument_list|>
name|r
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|all
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LabelType
name|l
range|:
name|all
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|refs
init|=
name|l
operator|.
name|getRefPatterns
argument_list|()
decl_stmt|;
if|if
condition|(
name|refs
operator|==
literal|null
condition|)
block|{
name|r
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|refPattern
range|:
name|refs
control|)
block|{
if|if
condition|(
name|refPattern
operator|.
name|contains
argument_list|(
literal|"${"
argument_list|)
condition|)
block|{
name|logger
operator|.
name|atWarning
argument_list|()
operator|.
name|log
argument_list|(
literal|"Ref pattern for label %s in project %s contains illegal expanded parameters: %s."
operator|+
literal|" Ref pattern will be ignored."
argument_list|,
name|l
argument_list|,
name|getName
argument_list|()
argument_list|,
name|refPattern
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|AccessSection
operator|.
name|isValidRefSectionName
argument_list|(
name|refPattern
argument_list|)
operator|&&
name|match
argument_list|(
name|destination
argument_list|,
name|refPattern
argument_list|)
condition|)
block|{
name|r
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
operator|new
name|LabelTypes
argument_list|(
name|r
argument_list|)
return|;
block|}
DECL|method|getCommentLinks ()
specifier|public
name|List
argument_list|<
name|CommentLinkInfo
argument_list|>
name|getCommentLinks
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|CommentLinkInfo
argument_list|>
name|cls
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CommentLinkInfo
name|cl
range|:
name|commentLinks
control|)
block|{
name|cls
operator|.
name|put
argument_list|(
name|cl
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ProjectState
name|s
range|:
name|treeInOrder
argument_list|()
control|)
block|{
for|for
control|(
name|CommentLinkInfoImpl
name|cl
range|:
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getCommentLinkSections
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|cl
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|isOverrideOnly
argument_list|()
condition|)
block|{
name|CommentLinkInfo
name|parent
init|=
name|cls
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// Ignore invalid overrides.
block|}
name|cls
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|cl
operator|.
name|inherit
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cls
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|cls
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getBranchOrderSection ()
specifier|public
name|BranchOrderSection
name|getBranchOrderSection
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|BranchOrderSection
name|section
init|=
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getBranchOrderSection
argument_list|()
decl_stmt|;
if|if
condition|(
name|section
operator|!=
literal|null
condition|)
block|{
return|return
name|section
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getSubscribeSections (Branch.NameKey branch)
specifier|public
name|Collection
argument_list|<
name|SubscribeSection
argument_list|>
name|getSubscribeSections
parameter_list|(
name|Branch
operator|.
name|NameKey
name|branch
parameter_list|)
block|{
name|Collection
argument_list|<
name|SubscribeSection
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|ret
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|getConfig
argument_list|()
operator|.
name|getSubscribeSections
argument_list|(
name|branch
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getAllGroups ()
specifier|public
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getAllGroups
parameter_list|()
block|{
return|return
name|getGroups
argument_list|(
name|getAllSections
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getLocalGroups ()
specifier|public
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getLocalGroups
parameter_list|()
block|{
return|return
name|getGroups
argument_list|(
name|getLocalAccessSections
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getSubmitType ()
specifier|public
name|SubmitType
name|getSubmitType
parameter_list|()
block|{
for|for
control|(
name|ProjectState
name|s
range|:
name|tree
argument_list|()
control|)
block|{
name|SubmitType
name|t
init|=
name|s
operator|.
name|getProject
argument_list|()
operator|.
name|getConfiguredSubmitType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|SubmitType
operator|.
name|INHERIT
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
return|return
name|Project
operator|.
name|DEFAULT_ALL_PROJECTS_SUBMIT_TYPE
return|;
block|}
DECL|method|getGroups (List<SectionMatcher> sectionMatcherList)
specifier|private
specifier|static
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|getGroups
parameter_list|(
name|List
argument_list|<
name|SectionMatcher
argument_list|>
name|sectionMatcherList
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|GroupReference
argument_list|>
name|all
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SectionMatcher
name|matcher
range|:
name|sectionMatcherList
control|)
block|{
specifier|final
name|AccessSection
name|section
init|=
name|matcher
operator|.
name|getSection
argument_list|()
decl_stmt|;
for|for
control|(
name|Permission
name|permission
range|:
name|section
operator|.
name|getPermissions
argument_list|()
control|)
block|{
for|for
control|(
name|PermissionRule
name|rule
range|:
name|permission
operator|.
name|getRules
argument_list|()
control|)
block|{
name|all
operator|.
name|add
argument_list|(
name|rule
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|all
return|;
block|}
DECL|method|toProjectData ()
specifier|public
name|ProjectData
name|toProjectData
parameter_list|()
block|{
name|ProjectData
name|project
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ProjectState
name|state
range|:
name|treeInOrder
argument_list|()
control|)
block|{
name|project
operator|=
operator|new
name|ProjectData
argument_list|(
name|state
operator|.
name|getProject
argument_list|()
argument_list|,
name|Optional
operator|.
name|ofNullable
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|project
return|;
block|}
DECL|method|match (Branch.NameKey destination, String refPattern)
specifier|private
name|boolean
name|match
parameter_list|(
name|Branch
operator|.
name|NameKey
name|destination
parameter_list|,
name|String
name|refPattern
parameter_list|)
block|{
return|return
name|RefPatternMatcher
operator|.
name|getMatcher
argument_list|(
name|refPattern
argument_list|)
operator|.
name|match
argument_list|(
name|destination
operator|.
name|get
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
end_class

end_unit

