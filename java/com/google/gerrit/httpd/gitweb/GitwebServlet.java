begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2009 The Android Open Source Project
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Licensed under the Apache License, Version 2.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License.
end_comment

begin_comment
comment|// You may obtain a copy of the License at
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// http://www.apache.org/licenses/LICENSE-2.0
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unless required by applicable law or agreed to in writing, software
end_comment

begin_comment
comment|// distributed under the License is distributed on an "AS IS" BASIS,
end_comment

begin_comment
comment|// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing permissions and
end_comment

begin_comment
comment|// limitations under the License.
end_comment

begin_comment
comment|// CGI environment and execution management portions are:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ========================================================================
end_comment

begin_comment
comment|// Copyright (c) 2006-2009 Mort Bay Consulting Pty. Ltd.
end_comment

begin_comment
comment|// ------------------------------------------------------------------------
end_comment

begin_comment
comment|// All rights reserved. This program and the accompanying materials
end_comment

begin_comment
comment|// are made available under the terms of the Eclipse Public License v1.0
end_comment

begin_comment
comment|// and Apache License v2.0 which accompanies this distribution.
end_comment

begin_comment
comment|// The Eclipse Public License is available at
end_comment

begin_comment
comment|// http://www.eclipse.org/legal/epl-v10.html
end_comment

begin_comment
comment|// The Apache License v2.0 is available at
end_comment

begin_comment
comment|// http://www.opensource.org/licenses/apache2.0.php
end_comment

begin_comment
comment|// You may elect to redistribute this code under either of these licenses.
end_comment

begin_comment
comment|// ========================================================================
end_comment

begin_package
DECL|package|com.google.gerrit.httpd.gitweb
package|package
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|httpd
operator|.
name|gitweb
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|ISO_8859_1
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|CharMatcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|flogger
operator|.
name|FluentLogger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|common
operator|.
name|PageLinks
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|restapi
operator|.
name|AuthException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|restapi
operator|.
name|ResourceConflictException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|extensions
operator|.
name|restapi
operator|.
name|Url
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|reviewdb
operator|.
name|client
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|AnonymousUser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|CurrentUser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|IdentifiedUser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|GerritServerConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|GitwebCgiConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|GitwebConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|config
operator|.
name|SitePaths
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|GitRepositoryManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|git
operator|.
name|LocalDiskRepositoryManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|permissions
operator|.
name|PermissionBackend
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|permissions
operator|.
name|PermissionBackendException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|permissions
operator|.
name|ProjectPermission
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|project
operator|.
name|ProjectCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|project
operator|.
name|ProjectState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|server
operator|.
name|ssh
operator|.
name|SshInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gwtexpui
operator|.
name|server
operator|.
name|CacheHeaders
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Provider
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|ProvisionException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Singleton
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|errors
operator|.
name|RepositoryNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Config
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jgit
operator|.
name|lib
operator|.
name|Repository
import|;
end_import

begin_comment
comment|/** Invokes {@code gitweb.cgi} for the project given in {@code p}. */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
annotation|@
name|Singleton
DECL|class|GitwebServlet
class|class
name|GitwebServlet
extends|extends
name|HttpServlet
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|FluentLogger
name|logger
init|=
name|FluentLogger
operator|.
name|forEnclosingClass
argument_list|()
decl_stmt|;
DECL|field|PROJECT_LIST_ACTION
specifier|private
specifier|static
specifier|final
name|String
name|PROJECT_LIST_ACTION
init|=
literal|"project_list"
decl_stmt|;
DECL|field|deniedActions
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|deniedActions
decl_stmt|;
DECL|field|bufferSize
specifier|private
specifier|final
name|int
name|bufferSize
init|=
literal|8192
decl_stmt|;
DECL|field|gitwebCgi
specifier|private
specifier|final
name|Path
name|gitwebCgi
decl_stmt|;
DECL|field|gitwebUrl
specifier|private
specifier|final
name|URI
name|gitwebUrl
decl_stmt|;
DECL|field|repoManager
specifier|private
specifier|final
name|LocalDiskRepositoryManager
name|repoManager
decl_stmt|;
DECL|field|projectCache
specifier|private
specifier|final
name|ProjectCache
name|projectCache
decl_stmt|;
DECL|field|permissionBackend
specifier|private
specifier|final
name|PermissionBackend
name|permissionBackend
decl_stmt|;
DECL|field|anonymousUserProvider
specifier|private
specifier|final
name|Provider
argument_list|<
name|AnonymousUser
argument_list|>
name|anonymousUserProvider
decl_stmt|;
DECL|field|userProvider
specifier|private
specifier|final
name|Provider
argument_list|<
name|CurrentUser
argument_list|>
name|userProvider
decl_stmt|;
DECL|field|_env
specifier|private
specifier|final
name|EnvList
name|_env
decl_stmt|;
annotation|@
name|Inject
DECL|method|GitwebServlet ( GitRepositoryManager repoManager, ProjectCache projectCache, PermissionBackend permissionBackend, Provider<CurrentUser> userProvider, SitePaths site, @GerritServerConfig Config cfg, SshInfo sshInfo, Provider<AnonymousUser> anonymousUserProvider, GitwebConfig gitwebConfig, GitwebCgiConfig gitwebCgiConfig)
name|GitwebServlet
parameter_list|(
name|GitRepositoryManager
name|repoManager
parameter_list|,
name|ProjectCache
name|projectCache
parameter_list|,
name|PermissionBackend
name|permissionBackend
parameter_list|,
name|Provider
argument_list|<
name|CurrentUser
argument_list|>
name|userProvider
parameter_list|,
name|SitePaths
name|site
parameter_list|,
annotation|@
name|GerritServerConfig
name|Config
name|cfg
parameter_list|,
name|SshInfo
name|sshInfo
parameter_list|,
name|Provider
argument_list|<
name|AnonymousUser
argument_list|>
name|anonymousUserProvider
parameter_list|,
name|GitwebConfig
name|gitwebConfig
parameter_list|,
name|GitwebCgiConfig
name|gitwebCgiConfig
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|repoManager
operator|instanceof
name|LocalDiskRepositoryManager
operator|)
condition|)
block|{
throw|throw
operator|new
name|ProvisionException
argument_list|(
literal|"Gitweb can only be used with LocalDiskRepositoryManager"
argument_list|)
throw|;
block|}
name|this
operator|.
name|repoManager
operator|=
operator|(
name|LocalDiskRepositoryManager
operator|)
name|repoManager
expr_stmt|;
name|this
operator|.
name|projectCache
operator|=
name|projectCache
expr_stmt|;
name|this
operator|.
name|permissionBackend
operator|=
name|permissionBackend
expr_stmt|;
name|this
operator|.
name|anonymousUserProvider
operator|=
name|anonymousUserProvider
expr_stmt|;
name|this
operator|.
name|userProvider
operator|=
name|userProvider
expr_stmt|;
name|this
operator|.
name|gitwebCgi
operator|=
name|gitwebCgiConfig
operator|.
name|getGitwebCgi
argument_list|()
expr_stmt|;
name|this
operator|.
name|deniedActions
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
specifier|final
name|String
name|url
init|=
name|gitwebConfig
operator|.
name|getUrl
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|url
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|url
operator|.
name|equals
argument_list|(
literal|"gitweb"
argument_list|)
operator|)
condition|)
block|{
name|URI
name|uri
init|=
literal|null
decl_stmt|;
try|try
block|{
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|log
argument_list|(
literal|"Invalid gitweb.url: %s"
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
name|gitwebUrl
operator|=
name|uri
expr_stmt|;
block|}
else|else
block|{
name|gitwebUrl
operator|=
literal|null
expr_stmt|;
block|}
name|deniedActions
operator|.
name|add
argument_list|(
literal|"forks"
argument_list|)
expr_stmt|;
name|deniedActions
operator|.
name|add
argument_list|(
literal|"opml"
argument_list|)
expr_stmt|;
name|deniedActions
operator|.
name|add
argument_list|(
literal|"project_index"
argument_list|)
expr_stmt|;
name|_env
operator|=
operator|new
name|EnvList
argument_list|()
expr_stmt|;
name|makeSiteConfig
argument_list|(
name|site
argument_list|,
name|cfg
argument_list|,
name|sshInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_env
operator|.
name|envMap
operator|.
name|containsKey
argument_list|(
literal|"SystemRoot"
argument_list|)
condition|)
block|{
name|String
name|os
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|os
operator|!=
literal|null
operator|&&
name|os
operator|.
name|toLowerCase
argument_list|()
operator|.
name|contains
argument_list|(
literal|"windows"
argument_list|)
condition|)
block|{
name|String
name|sysroot
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"SystemRoot"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysroot
operator|==
literal|null
operator|||
name|sysroot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sysroot
operator|=
literal|"C:\\WINDOWS"
expr_stmt|;
block|}
name|_env
operator|.
name|set
argument_list|(
literal|"SystemRoot"
argument_list|,
name|sysroot
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|_env
operator|.
name|envMap
operator|.
name|containsKey
argument_list|(
literal|"PATH"
argument_list|)
condition|)
block|{
name|_env
operator|.
name|set
argument_list|(
literal|"PATH"
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|makeSiteConfig (SitePaths site, Config cfg, SshInfo sshInfo)
specifier|private
name|void
name|makeSiteConfig
parameter_list|(
name|SitePaths
name|site
parameter_list|,
name|Config
name|cfg
parameter_list|,
name|SshInfo
name|sshInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|site
operator|.
name|tmp_dir
argument_list|)
condition|)
block|{
name|Files
operator|.
name|createDirectories
argument_list|(
name|site
operator|.
name|tmp_dir
argument_list|)
expr_stmt|;
block|}
name|Path
name|myconf
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|site
operator|.
name|tmp_dir
argument_list|,
literal|"gitweb_config"
argument_list|,
literal|".perl"
argument_list|)
decl_stmt|;
comment|// To make our configuration file only readable or writable by us;
comment|// this reduces the chances of someone tampering with the file.
comment|//
comment|// TODO(dborowitz): Is there a portable way to do this with NIO?
name|File
name|myconfFile
init|=
name|myconf
operator|.
name|toFile
argument_list|()
decl_stmt|;
name|myconfFile
operator|.
name|setWritable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|myconfFile
operator|.
name|setReadable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|myconfFile
operator|.
name|setExecutable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|myconfFile
operator|.
name|setWritable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|myconfFile
operator|.
name|setReadable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|myconfFile
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|_env
operator|.
name|set
argument_list|(
literal|"GIT_DIR"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|_env
operator|.
name|set
argument_list|(
literal|"GITWEB_CONFIG"
argument_list|,
name|myconf
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|PrintWriter
name|p
init|=
operator|new
name|PrintWriter
argument_list|(
name|Files
operator|.
name|newBufferedWriter
argument_list|(
name|myconf
argument_list|,
name|UTF_8
argument_list|)
argument_list|)
init|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|"# Autogenerated by Gerrit Code Review \n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"# DO NOT EDIT\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// We are mounted at the same level in the context as the main
comment|// UI, so we can include the same header and footer scheme.
comment|//
name|Path
name|hdr
init|=
name|site
operator|.
name|site_header
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|"$site_header = "
operator|+
name|quoteForPerl
argument_list|(
name|hdr
argument_list|)
operator|+
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|Path
name|ftr
init|=
name|site
operator|.
name|site_footer
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|ftr
argument_list|)
condition|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|"$site_footer = "
operator|+
name|quoteForPerl
argument_list|(
name|ftr
argument_list|)
operator|+
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|// Top level should return to Gerrit's UI.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$home_link_str = 'Code Review';\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$favicon = 'favicon.ico';\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$logo = 'gitweb-logo.png';\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$javascript = 'gitweb.js';\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"@stylesheets = ('gitweb-default.css');\n"
argument_list|)
expr_stmt|;
name|Path
name|css
init|=
name|site
operator|.
name|site_css
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|css
argument_list|)
condition|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|"push @stylesheets, 'gitweb-site.css';\n"
argument_list|)
expr_stmt|;
block|}
comment|// Try to make the title match Gerrit's normal window title
comment|// scheme of host followed by 'Code Review'.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$site_name = $home_link_str;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$site_name = qq{$1 $site_name} if "
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n"
argument_list|)
expr_stmt|;
comment|// Assume by default that XSS is a problem, and try to prevent it.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$prevent_xss = 1;\n"
argument_list|)
expr_stmt|;
comment|// Generate URLs using smart http://
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $http_url = $secure ? 'https://' : 'http://';\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  $http_url .= $ENV{'SERVER_NAME'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    if (( $secure&& $ENV{'SERVER_PORT'} != 443)\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"     || (!$secure&& $ENV{'SERVER_PORT'} != 80)\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    );\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $context = $ENV{'GERRIT_CONTEXT_PATH'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  chop($context);\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  $http_url .= qq{$context};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  $http_url .= qq{/a}\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  push @git_base_url_list, $http_url;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
comment|// Generate URLs using anonymous git://
comment|//
name|String
name|url
init|=
name|cfg
operator|.
name|getString
argument_list|(
literal|"gerrit"
argument_list|,
literal|null
argument_list|,
literal|"canonicalGitUrl"
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|url
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|url
operator|=
name|url
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|url
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|print
argument_list|(
literal|"if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  push @git_base_url_list, "
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
name|quoteForPerl
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|// Generate URLs using authenticated ssh://
comment|//
if|if
condition|(
name|sshInfo
operator|!=
literal|null
operator|&&
operator|!
name|sshInfo
operator|.
name|getHostKeys
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|sshAddr
init|=
name|sshInfo
operator|.
name|getHostKeys
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"if ($ENV{'GERRIT_USER_NAME'}) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  push @git_base_url_list, join('', 'ssh://'"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|", $ENV{'GERRIT_USER_NAME'}"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|", '@'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshAddr
operator|.
name|startsWith
argument_list|(
literal|"*:"
argument_list|)
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|sshAddr
argument_list|)
condition|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|", $ENV{'SERVER_NAME'}"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sshAddr
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|sshAddr
operator|=
name|sshAddr
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|print
argument_list|(
literal|", "
operator|+
name|quoteForPerl
argument_list|(
name|sshAddr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|// Link back to Gerrit (when possible, to matching review record).
comment|// Supported gitweb's hash values are:
comment|// - (missing),
comment|// - HEAD,
comment|// - refs/heads/<branch>,
comment|// - refs/changes/*/<change>/*,
comment|// -<revision>.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"sub add_review_link {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $h = shift;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $q;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  if (!$h || $h eq 'HEAD') {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"+branch:$1};\n"
argument_list|)
expr_stmt|;
comment|// wrapped
name|p
operator|.
name|print
argument_list|(
literal|"  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) "
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|// wrapped
name|p
operator|.
name|print
argument_list|(
literal|"    $q = qq{#/c/$1};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  } else {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    $q = qq{#/q/$h};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  }\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  push @{$feature{'actions'}{'default'}},\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"      ('review',$r,'commitdiff');\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"if ($cgi->param('hb')) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  add_review_link(scalar $cgi->param('hb'));\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"} elsif ($cgi->param('h')) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  add_review_link(scalar $cgi->param('h'));\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"} else {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  add_review_link();\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
comment|// If the administrator has created a site-specific gitweb_config,
comment|// load that before we perform any final overrides.
comment|//
name|Path
name|sitecfg
init|=
name|site
operator|.
name|site_gitweb
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|sitecfg
argument_list|)
condition|)
block|{
name|p
operator|.
name|print
argument_list|(
literal|"$GITWEB_CONFIG = "
operator|+
name|quoteForPerl
argument_list|(
name|sitecfg
argument_list|)
operator|+
literal|";\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"if (-e $GITWEB_CONFIG) {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  do "
operator|+
name|quoteForPerl
argument_list|(
name|sitecfg
argument_list|)
operator|+
literal|";\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|print
argument_list|(
literal|"$projectroot = $ENV{'GITWEB_PROJECTROOT'};\n"
argument_list|)
expr_stmt|;
comment|// Permit exporting only the project we were started for.
comment|// We use the name under $projectroot in case symlinks
comment|// were involved in the path.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$export_auth_hook = sub {\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    my $dir = shift;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    my $allow = qq{$projectroot/$name.git};\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"    return $dir eq $allow;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
comment|// Do not allow the administrator to enable path info, its
comment|// not a URL format we currently support.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$feature{'pathinfo'}{'override'} = 0;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$feature{'pathinfo'}{'default'} = [0];\n"
argument_list|)
expr_stmt|;
comment|// We don't do forking, so don't allow it to be enabled.
comment|//
name|p
operator|.
name|print
argument_list|(
literal|"$feature{'forks'}{'override'} = 0;\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|print
argument_list|(
literal|"$feature{'forks'}{'default'} = [0];\n"
argument_list|)
expr_stmt|;
block|}
name|myconfFile
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
block|}
DECL|method|quoteForPerl (Path value)
specifier|private
specifier|static
name|String
name|quoteForPerl
parameter_list|(
name|Path
name|value
parameter_list|)
block|{
return|return
name|quoteForPerl
argument_list|(
name|value
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|quoteForPerl (String value)
specifier|private
specifier|static
name|String
name|quoteForPerl
parameter_list|(
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"''"
return|;
block|}
if|if
condition|(
operator|!
name|value
operator|.
name|contains
argument_list|(
literal|"'"
argument_list|)
condition|)
block|{
return|return
literal|"'"
operator|+
name|value
operator|+
literal|"'"
return|;
block|}
if|if
condition|(
operator|!
name|value
operator|.
name|contains
argument_list|(
literal|"{"
argument_list|)
operator|&&
operator|!
name|value
operator|.
name|contains
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
return|return
literal|"q{"
operator|+
name|value
operator|+
literal|"}"
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot quote in Perl: "
operator|+
name|value
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|service (HttpServletRequest req, HttpServletResponse rsp)
specifier|protected
name|void
name|service
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|rsp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|req
operator|.
name|getQueryString
argument_list|()
operator|==
literal|null
operator|||
name|req
operator|.
name|getQueryString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No query string? They want the project list, which we don't
comment|// currently support. Return to Gerrit's own web UI.
comment|//
name|rsp
operator|.
name|sendRedirect
argument_list|(
name|req
operator|.
name|getContextPath
argument_list|()
operator|+
literal|"/"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
name|getParameters
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|String
name|a
init|=
name|params
operator|.
name|get
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deniedActions
operator|.
name|contains
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|rsp
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_FORBIDDEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|a
operator|.
name|equals
argument_list|(
name|PROJECT_LIST_ACTION
argument_list|)
condition|)
block|{
name|rsp
operator|.
name|sendRedirect
argument_list|(
name|req
operator|.
name|getContextPath
argument_list|()
operator|+
literal|"/#"
operator|+
name|PageLinks
operator|.
name|ADMIN_PROJECTS
operator|+
literal|"?filter="
operator|+
name|Url
operator|.
name|encode
argument_list|(
name|params
operator|.
name|get
argument_list|(
literal|"pf"
argument_list|)
operator|+
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|String
name|name
init|=
name|params
operator|.
name|get
argument_list|(
literal|"p"
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|rsp
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_NOT_FOUND
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|".git"
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
name|Project
operator|.
name|NameKey
name|nameKey
init|=
operator|new
name|Project
operator|.
name|NameKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ProjectState
name|projectState
decl_stmt|;
try|try
block|{
name|projectState
operator|=
name|projectCache
operator|.
name|checkedGet
argument_list|(
name|nameKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|projectState
operator|==
literal|null
condition|)
block|{
name|sendErrorOrRedirect
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
name|HttpServletResponse
operator|.
name|SC_NOT_FOUND
argument_list|)
expr_stmt|;
return|return;
block|}
name|projectState
operator|.
name|checkStatePermitsRead
argument_list|()
expr_stmt|;
name|permissionBackend
operator|.
name|user
argument_list|(
name|userProvider
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|project
argument_list|(
name|nameKey
argument_list|)
operator|.
name|check
argument_list|(
name|ProjectPermission
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthException
name|e
parameter_list|)
block|{
name|sendErrorOrRedirect
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
name|HttpServletResponse
operator|.
name|SC_NOT_FOUND
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|PermissionBackendException
name|err
parameter_list|)
block|{
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|withCause
argument_list|(
name|err
argument_list|)
operator|.
name|log
argument_list|(
literal|"cannot load %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_INTERNAL_SERVER_ERROR
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ResourceConflictException
name|e
parameter_list|)
block|{
name|sendErrorOrRedirect
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
name|HttpServletResponse
operator|.
name|SC_CONFLICT
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
init|(
name|Repository
name|repo
init|=
name|repoManager
operator|.
name|openRepository
argument_list|(
name|nameKey
argument_list|)
init|)
block|{
name|CacheHeaders
operator|.
name|setNotCacheable
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
name|exec
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|,
name|projectState
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryNotFoundException
name|e
parameter_list|)
block|{
name|getServletContext
argument_list|()
operator|.
name|log
argument_list|(
literal|"Cannot open repository"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_INTERNAL_SERVER_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sends error response if the user is authenticated. Or redirect the user to the login page. By    * doing this, anonymous users cannot infer the existence of a resource from the status code.    */
DECL|method|sendErrorOrRedirect (HttpServletRequest req, HttpServletResponse rsp, int statusCode)
specifier|private
name|void
name|sendErrorOrRedirect
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|rsp
parameter_list|,
name|int
name|statusCode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|userProvider
operator|.
name|get
argument_list|()
operator|.
name|isIdentifiedUser
argument_list|()
condition|)
block|{
name|rsp
operator|.
name|sendError
argument_list|(
name|statusCode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsp
operator|.
name|sendRedirect
argument_list|(
name|getLoginRedirectUrl
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getLoginRedirectUrl (HttpServletRequest req)
specifier|private
specifier|static
name|String
name|getLoginRedirectUrl
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|)
block|{
name|String
name|contextPath
init|=
name|req
operator|.
name|getContextPath
argument_list|()
decl_stmt|;
name|String
name|loginUrl
init|=
name|contextPath
operator|+
literal|"/login/"
decl_stmt|;
name|String
name|token
init|=
name|req
operator|.
name|getRequestURI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|contextPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|token
operator|=
name|token
operator|.
name|substring
argument_list|(
name|contextPath
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|queryString
init|=
name|req
operator|.
name|getQueryString
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryString
operator|!=
literal|null
operator|&&
operator|!
name|queryString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|token
operator|=
name|token
operator|+
literal|"?"
operator|+
name|queryString
expr_stmt|;
block|}
return|return
operator|(
name|loginUrl
operator|+
name|Url
operator|.
name|encode
argument_list|(
name|token
argument_list|)
operator|)
return|;
block|}
DECL|method|getParameters (HttpServletRequest req)
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getParameters
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|pair
range|:
name|Splitter
operator|.
name|on
argument_list|(
name|CharMatcher
operator|.
name|anyOf
argument_list|(
literal|"&;"
argument_list|)
argument_list|)
operator|.
name|split
argument_list|(
name|req
operator|.
name|getQueryString
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|int
name|eq
init|=
name|pair
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|eq
condition|)
block|{
name|String
name|name
init|=
name|pair
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|eq
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|pair
operator|.
name|substring
argument_list|(
name|eq
operator|+
literal|1
argument_list|)
decl_stmt|;
name|name
operator|=
name|Url
operator|.
name|decode
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|Url
operator|.
name|decode
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|params
return|;
block|}
DECL|method|exec (HttpServletRequest req, HttpServletResponse rsp, ProjectState projectState)
specifier|private
name|void
name|exec
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|rsp
parameter_list|,
name|ProjectState
name|projectState
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Process
name|proc
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exec
argument_list|(
operator|new
name|String
index|[]
block|{
name|gitwebCgi
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
block|}
argument_list|,
name|makeEnv
argument_list|(
name|req
argument_list|,
name|projectState
argument_list|)
argument_list|,
name|gitwebCgi
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|toFile
argument_list|()
argument_list|)
decl_stmt|;
name|copyStderrToLog
argument_list|(
name|proc
operator|.
name|getErrorStream
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|req
operator|.
name|getContentLength
argument_list|()
condition|)
block|{
name|copyContentToCGI
argument_list|(
name|req
argument_list|,
name|proc
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proc
operator|.
name|getOutputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
try|try
init|(
name|InputStream
name|in
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|proc
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|bufferSize
argument_list|)
init|)
block|{
name|readCgiHeaders
argument_list|(
name|rsp
argument_list|,
name|in
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|out
init|=
name|rsp
operator|.
name|getOutputStream
argument_list|()
init|)
block|{
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|bufferSize
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// The browser has probably closed its input stream. We don't
comment|// want to continue executing this request.
comment|//
name|proc
operator|.
name|destroy
argument_list|()
expr_stmt|;
return|return;
block|}
try|try
block|{
name|proc
operator|.
name|waitFor
argument_list|()
expr_stmt|;
specifier|final
name|int
name|status
init|=
name|proc
operator|.
name|exitValue
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|status
condition|)
block|{
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|log
argument_list|(
literal|"Non-zero exit status (%d) from %s"
argument_list|,
name|status
argument_list|,
name|gitwebCgi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsp
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
name|rsp
operator|.
name|sendError
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|logger
operator|.
name|atFine
argument_list|()
operator|.
name|log
argument_list|(
literal|"CGI: interrupted waiting for CGI to terminate"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|makeEnv (HttpServletRequest req, ProjectState projectState)
specifier|private
name|String
index|[]
name|makeEnv
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|ProjectState
name|projectState
parameter_list|)
block|{
specifier|final
name|EnvList
name|env
init|=
operator|new
name|EnvList
argument_list|(
name|_env
argument_list|)
decl_stmt|;
specifier|final
name|int
name|contentLength
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|req
operator|.
name|getContentLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// These ones are from "The WWW Common Gateway Interface Version 1.1"
comment|//
name|env
operator|.
name|set
argument_list|(
literal|"AUTH_TYPE"
argument_list|,
name|req
operator|.
name|getAuthType
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"CONTENT_LENGTH"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|contentLength
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"CONTENT_TYPE"
argument_list|,
name|req
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"GATEWAY_INTERFACE"
argument_list|,
literal|"CGI/1.1"
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"PATH_INFO"
argument_list|,
name|req
operator|.
name|getPathInfo
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"PATH_TRANSLATED"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"QUERY_STRING"
argument_list|,
name|req
operator|.
name|getQueryString
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"REMOTE_ADDR"
argument_list|,
name|req
operator|.
name|getRemoteAddr
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"REMOTE_HOST"
argument_list|,
name|req
operator|.
name|getRemoteHost
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"HTTPS"
argument_list|,
name|req
operator|.
name|isSecure
argument_list|()
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
comment|// The identity information reported about the connection by a
comment|// RFC 1413 [11] request to the remote agent, if
comment|// available. Servers MAY choose not to support this feature, or
comment|// not to request the data for efficiency reasons.
comment|// "REMOTE_IDENT" => "NYI"
comment|//
name|env
operator|.
name|set
argument_list|(
literal|"REQUEST_METHOD"
argument_list|,
name|req
operator|.
name|getMethod
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SCRIPT_NAME"
argument_list|,
name|req
operator|.
name|getContextPath
argument_list|()
operator|+
name|req
operator|.
name|getServletPath
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SCRIPT_FILENAME"
argument_list|,
name|gitwebCgi
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_NAME"
argument_list|,
name|req
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_PORT"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|req
operator|.
name|getServerPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_PROTOCOL"
argument_list|,
name|req
operator|.
name|getProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_SOFTWARE"
argument_list|,
name|getServletContext
argument_list|()
operator|.
name|getServerInfo
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Enumeration
argument_list|<
name|String
argument_list|>
name|hdrs
init|=
name|enumerateHeaderNames
argument_list|(
name|req
argument_list|)
decl_stmt|;
while|while
condition|(
name|hdrs
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
specifier|final
name|String
name|name
init|=
name|hdrs
operator|.
name|nextElement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|value
init|=
name|req
operator|.
name|getHeader
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"HTTP_"
operator|+
name|name
operator|.
name|toUpperCase
argument_list|()
operator|.
name|replace
argument_list|(
literal|'-'
argument_list|,
literal|'_'
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|Project
operator|.
name|NameKey
name|nameKey
init|=
name|projectState
operator|.
name|getNameKey
argument_list|()
decl_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"GERRIT_CONTEXT_PATH"
argument_list|,
name|req
operator|.
name|getContextPath
argument_list|()
operator|+
literal|"/"
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"GERRIT_PROJECT_NAME"
argument_list|,
name|nameKey
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"GITWEB_PROJECTROOT"
argument_list|,
name|repoManager
operator|.
name|getBasePath
argument_list|(
name|nameKey
argument_list|)
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|projectState
operator|.
name|statePermitsRead
argument_list|()
operator|&&
name|permissionBackend
operator|.
name|user
argument_list|(
name|anonymousUserProvider
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|project
argument_list|(
name|nameKey
argument_list|)
operator|.
name|testOrFalse
argument_list|(
name|ProjectPermission
operator|.
name|READ
argument_list|)
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"GERRIT_ANONYMOUS_READ"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
name|String
name|remoteUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userProvider
operator|.
name|get
argument_list|()
operator|.
name|isIdentifiedUser
argument_list|()
condition|)
block|{
name|IdentifiedUser
name|u
init|=
name|userProvider
operator|.
name|get
argument_list|()
operator|.
name|asIdentifiedUser
argument_list|()
decl_stmt|;
name|Optional
argument_list|<
name|String
argument_list|>
name|user
init|=
name|u
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"GERRIT_USER_NAME"
argument_list|,
name|user
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|remoteUser
operator|=
name|user
operator|.
name|orElseGet
argument_list|(
parameter_list|()
lambda|->
literal|"account-"
operator|+
name|u
operator|.
name|getAccountId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|set
argument_list|(
literal|"REMOTE_USER"
argument_list|,
name|remoteUser
argument_list|)
expr_stmt|;
comment|// Override CGI settings using alternative URI provided by gitweb.url.
comment|// This is required to trick gitweb into thinking that it's served under
comment|// different URL. Setting just $my_uri on the perl's side isn't enough,
comment|// because few actions (atom, blobdiff_plain, commitdiff_plain) rely on
comment|// URL returned by $cgi->self_url().
comment|//
if|if
condition|(
name|gitwebUrl
operator|!=
literal|null
condition|)
block|{
name|int
name|schemePort
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gitwebUrl
operator|.
name|getScheme
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|gitwebUrl
operator|.
name|getScheme
argument_list|()
operator|.
name|equals
argument_list|(
literal|"http"
argument_list|)
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"HTTPS"
argument_list|,
literal|"OFF"
argument_list|)
expr_stmt|;
name|schemePort
operator|=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|env
operator|.
name|set
argument_list|(
literal|"HTTPS"
argument_list|,
literal|"ON"
argument_list|)
expr_stmt|;
name|schemePort
operator|=
literal|443
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gitwebUrl
operator|.
name|getHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_NAME"
argument_list|,
name|gitwebUrl
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|set
argument_list|(
literal|"HTTP_HOST"
argument_list|,
name|gitwebUrl
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gitwebUrl
operator|.
name|getPort
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_PORT"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|gitwebUrl
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schemePort
operator|!=
operator|-
literal|1
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"SERVER_PORT"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|schemePort
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gitwebUrl
operator|.
name|getPath
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|env
operator|.
name|set
argument_list|(
literal|"SCRIPT_NAME"
argument_list|,
name|gitwebUrl
operator|.
name|getPath
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"/"
else|:
name|gitwebUrl
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|env
operator|.
name|getEnvArray
argument_list|()
return|;
block|}
DECL|method|copyContentToCGI (HttpServletRequest req, OutputStream dst)
specifier|private
name|void
name|copyContentToCGI
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|OutputStream
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|contentLength
init|=
name|req
operator|.
name|getContentLength
argument_list|()
decl_stmt|;
specifier|final
name|InputStream
name|src
init|=
name|req
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
try|try
block|{
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|bufferSize
index|]
decl_stmt|;
name|int
name|remaining
init|=
name|contentLength
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|remaining
condition|)
block|{
specifier|final
name|int
name|max
init|=
name|Math
operator|.
name|max
argument_list|(
name|buf
operator|.
name|length
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|src
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Expected "
operator|+
name|remaining
operator|+
literal|" more bytes"
argument_list|)
throw|;
block|}
name|dst
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|n
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|dst
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|withCause
argument_list|(
name|e
argument_list|)
operator|.
name|log
argument_list|(
literal|"Unexpected error copying input to CGI"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|"Gitweb-InputFeeder"
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|copyStderrToLog (InputStream in)
specifier|private
name|void
name|copyStderrToLog
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
try|try
init|(
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|,
name|ISO_8859_1
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"CGI: "
argument_list|)
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|log
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|atSevere
argument_list|()
operator|.
name|withCause
argument_list|(
name|e
argument_list|)
operator|.
name|log
argument_list|(
literal|"Unexpected error copying stderr from CGI"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|"Gitweb-ErrorLogger"
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|enumerateHeaderNames (HttpServletRequest req)
specifier|private
specifier|static
name|Enumeration
argument_list|<
name|String
argument_list|>
name|enumerateHeaderNames
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|)
block|{
return|return
name|req
operator|.
name|getHeaderNames
argument_list|()
return|;
block|}
DECL|method|readCgiHeaders (HttpServletResponse res, InputStream in)
specifier|private
name|void
name|readCgiHeaders
parameter_list|(
name|HttpServletResponse
name|res
parameter_list|,
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|line
operator|=
name|readLine
argument_list|(
name|in
argument_list|)
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"HTTP"
argument_list|)
condition|)
block|{
comment|// CGI believes it is a non-parsed-header CGI. We refuse
comment|// to support that here so abort.
comment|//
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NPH CGI not supported: "
operator|+
name|line
argument_list|)
throw|;
block|}
specifier|final
name|int
name|sep
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CGI returned invalid header: "
operator|+
name|line
argument_list|)
throw|;
block|}
specifier|final
name|String
name|key
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sep
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|String
name|value
init|=
name|line
operator|.
name|substring
argument_list|(
name|sep
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"Location"
operator|.
name|equalsIgnoreCase
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|res
operator|.
name|sendRedirect
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"Status"
operator|.
name|equalsIgnoreCase
argument_list|(
name|key
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|token
init|=
name|Splitter
operator|.
name|on
argument_list|(
literal|' '
argument_list|)
operator|.
name|splitToList
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|final
name|int
name|status
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|res
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|addHeader
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|readLine (InputStream in)
specifier|private
name|String
name|readLine
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|b
operator|!=
literal|'\n'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
comment|/** private utility class that manages the Environment passed to exec. */
DECL|class|EnvList
specifier|private
specifier|static
class|class
name|EnvList
block|{
DECL|field|envMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envMap
decl_stmt|;
DECL|method|EnvList ()
name|EnvList
parameter_list|()
block|{
name|envMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|EnvList (EnvList l)
name|EnvList
parameter_list|(
name|EnvList
name|l
parameter_list|)
block|{
name|envMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|l
operator|.
name|envMap
argument_list|)
expr_stmt|;
block|}
comment|/** Set a name/value pair, null values will be treated as an empty String */
DECL|method|set (String name, String value)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
literal|""
expr_stmt|;
block|}
name|envMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|name
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Get representation suitable for passing to exec. */
DECL|method|getEnvArray ()
specifier|public
name|String
index|[]
name|getEnvArray
parameter_list|()
block|{
return|return
name|envMap
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|envMap
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|envMap
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

